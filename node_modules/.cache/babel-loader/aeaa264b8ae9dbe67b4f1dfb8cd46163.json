{"ast":null,"code":"function _extends() {\n  _extends = Object.assign ? Object.assign.bind() : function (target) {\n    for (var i = 1; i < arguments.length; i++) {\n      var source = arguments[i];\n\n      for (var key in source) {\n        if (Object.prototype.hasOwnProperty.call(source, key)) {\n          target[key] = source[key];\n        }\n      }\n    }\n\n    return target;\n  };\n  return _extends.apply(this, arguments);\n}\n\nfunction _inheritsLoose(subClass, superClass) {\n  subClass.prototype = Object.create(superClass.prototype);\n  subClass.prototype.constructor = subClass;\n\n  _setPrototypeOf(subClass, superClass);\n}\n\nfunction _getPrototypeOf(o) {\n  _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function _getPrototypeOf(o) {\n    return o.__proto__ || Object.getPrototypeOf(o);\n  };\n  return _getPrototypeOf(o);\n}\n\nfunction _setPrototypeOf(o, p) {\n  _setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function _setPrototypeOf(o, p) {\n    o.__proto__ = p;\n    return o;\n  };\n  return _setPrototypeOf(o, p);\n}\n\nfunction _isNativeReflectConstruct() {\n  if (typeof Reflect === \"undefined\" || !Reflect.construct) return false;\n  if (Reflect.construct.sham) return false;\n  if (typeof Proxy === \"function\") return true;\n\n  try {\n    Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {}));\n    return true;\n  } catch (e) {\n    return false;\n  }\n}\n\nfunction _construct(Parent, args, Class) {\n  if (_isNativeReflectConstruct()) {\n    _construct = Reflect.construct.bind();\n  } else {\n    _construct = function _construct(Parent, args, Class) {\n      var a = [null];\n      a.push.apply(a, args);\n      var Constructor = Function.bind.apply(Parent, a);\n      var instance = new Constructor();\n      if (Class) _setPrototypeOf(instance, Class.prototype);\n      return instance;\n    };\n  }\n\n  return _construct.apply(null, arguments);\n}\n\nfunction _isNativeFunction(fn) {\n  return Function.toString.call(fn).indexOf(\"[native code]\") !== -1;\n}\n\nfunction _wrapNativeSuper(Class) {\n  var _cache = typeof Map === \"function\" ? new Map() : undefined;\n\n  _wrapNativeSuper = function _wrapNativeSuper(Class) {\n    if (Class === null || !_isNativeFunction(Class)) return Class;\n\n    if (typeof Class !== \"function\") {\n      throw new TypeError(\"Super expression must either be null or a function\");\n    }\n\n    if (typeof _cache !== \"undefined\") {\n      if (_cache.has(Class)) return _cache.get(Class);\n\n      _cache.set(Class, Wrapper);\n    }\n\n    function Wrapper() {\n      return _construct(Class, arguments, _getPrototypeOf(this).constructor);\n    }\n\n    Wrapper.prototype = Object.create(Class.prototype, {\n      constructor: {\n        value: Wrapper,\n        enumerable: false,\n        writable: true,\n        configurable: true\n      }\n    });\n    return _setPrototypeOf(Wrapper, Class);\n  };\n\n  return _wrapNativeSuper(Class);\n}\n/* eslint no-console:0 */\n\n\nvar formatRegExp = /%[sdj%]/g;\n\nvar warning = function warning() {}; // don't print warning message when in production env or node runtime\n\n\nif (typeof process !== 'undefined' && process.env && process.env.NODE_ENV !== 'production' && typeof window !== 'undefined' && typeof document !== 'undefined') {\n  warning = function warning(type, errors) {\n    if (typeof console !== 'undefined' && console.warn && typeof ASYNC_VALIDATOR_NO_WARNING === 'undefined') {\n      if (errors.every(function (e) {\n        return typeof e === 'string';\n      })) {\n        console.warn(type, errors);\n      }\n    }\n  };\n}\n\nfunction convertFieldsError(errors) {\n  if (!errors || !errors.length) return null;\n  var fields = {};\n  errors.forEach(function (error) {\n    var field = error.field;\n    fields[field] = fields[field] || [];\n    fields[field].push(error);\n  });\n  return fields;\n}\n\nfunction format(template) {\n  for (var _len = arguments.length, args = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {\n    args[_key - 1] = arguments[_key];\n  }\n\n  var i = 0;\n  var len = args.length;\n\n  if (typeof template === 'function') {\n    return template.apply(null, args);\n  }\n\n  if (typeof template === 'string') {\n    var str = template.replace(formatRegExp, function (x) {\n      if (x === '%%') {\n        return '%';\n      }\n\n      if (i >= len) {\n        return x;\n      }\n\n      switch (x) {\n        case '%s':\n          return String(args[i++]);\n\n        case '%d':\n          return Number(args[i++]);\n\n        case '%j':\n          try {\n            return JSON.stringify(args[i++]);\n          } catch (_) {\n            return '[Circular]';\n          }\n\n          break;\n\n        default:\n          return x;\n      }\n    });\n    return str;\n  }\n\n  return template;\n}\n\nfunction isNativeStringType(type) {\n  return type === 'string' || type === 'url' || type === 'hex' || type === 'email' || type === 'date' || type === 'pattern';\n}\n\nfunction isEmptyValue(value, type) {\n  if (value === undefined || value === null) {\n    return true;\n  }\n\n  if (type === 'array' && Array.isArray(value) && !value.length) {\n    return true;\n  }\n\n  if (isNativeStringType(type) && typeof value === 'string' && !value) {\n    return true;\n  }\n\n  return false;\n}\n\nfunction asyncParallelArray(arr, func, callback) {\n  var results = [];\n  var total = 0;\n  var arrLength = arr.length;\n\n  function count(errors) {\n    results.push.apply(results, errors || []);\n    total++;\n\n    if (total === arrLength) {\n      callback(results);\n    }\n  }\n\n  arr.forEach(function (a) {\n    func(a, count);\n  });\n}\n\nfunction asyncSerialArray(arr, func, callback) {\n  var index = 0;\n  var arrLength = arr.length;\n\n  function next(errors) {\n    if (errors && errors.length) {\n      callback(errors);\n      return;\n    }\n\n    var original = index;\n    index = index + 1;\n\n    if (original < arrLength) {\n      func(arr[original], next);\n    } else {\n      callback([]);\n    }\n  }\n\n  next([]);\n}\n\nfunction flattenObjArr(objArr) {\n  var ret = [];\n  Object.keys(objArr).forEach(function (k) {\n    ret.push.apply(ret, objArr[k] || []);\n  });\n  return ret;\n}\n\nvar AsyncValidationError = /*#__PURE__*/function (_Error) {\n  _inheritsLoose(AsyncValidationError, _Error);\n\n  function AsyncValidationError(errors, fields) {\n    var _this;\n\n    _this = _Error.call(this, 'Async Validation Error') || this;\n    _this.errors = errors;\n    _this.fields = fields;\n    return _this;\n  }\n\n  return AsyncValidationError;\n}( /*#__PURE__*/_wrapNativeSuper(Error));\n\nfunction asyncMap(objArr, option, func, callback, source) {\n  if (option.first) {\n    var _pending = new Promise(function (resolve, reject) {\n      var next = function next(errors) {\n        callback(errors);\n        return errors.length ? reject(new AsyncValidationError(errors, convertFieldsError(errors))) : resolve(source);\n      };\n\n      var flattenArr = flattenObjArr(objArr);\n      asyncSerialArray(flattenArr, func, next);\n    });\n\n    _pending[\"catch\"](function (e) {\n      return e;\n    });\n\n    return _pending;\n  }\n\n  var firstFields = option.firstFields === true ? Object.keys(objArr) : option.firstFields || [];\n  var objArrKeys = Object.keys(objArr);\n  var objArrLength = objArrKeys.length;\n  var total = 0;\n  var results = [];\n  var pending = new Promise(function (resolve, reject) {\n    var next = function next(errors) {\n      results.push.apply(results, errors);\n      total++;\n\n      if (total === objArrLength) {\n        callback(results);\n        return results.length ? reject(new AsyncValidationError(results, convertFieldsError(results))) : resolve(source);\n      }\n    };\n\n    if (!objArrKeys.length) {\n      callback(results);\n      resolve(source);\n    }\n\n    objArrKeys.forEach(function (key) {\n      var arr = objArr[key];\n\n      if (firstFields.indexOf(key) !== -1) {\n        asyncSerialArray(arr, func, next);\n      } else {\n        asyncParallelArray(arr, func, next);\n      }\n    });\n  });\n  pending[\"catch\"](function (e) {\n    return e;\n  });\n  return pending;\n}\n\nfunction isErrorObj(obj) {\n  return !!(obj && obj.message !== undefined);\n}\n\nfunction getValue(value, path) {\n  var v = value;\n\n  for (var i = 0; i < path.length; i++) {\n    if (v == undefined) {\n      return v;\n    }\n\n    v = v[path[i]];\n  }\n\n  return v;\n}\n\nfunction complementError(rule, source) {\n  return function (oe) {\n    var fieldValue;\n\n    if (rule.fullFields) {\n      fieldValue = getValue(source, rule.fullFields);\n    } else {\n      fieldValue = source[oe.field || rule.fullField];\n    }\n\n    if (isErrorObj(oe)) {\n      oe.field = oe.field || rule.fullField;\n      oe.fieldValue = fieldValue;\n      return oe;\n    }\n\n    return {\n      message: typeof oe === 'function' ? oe() : oe,\n      fieldValue: fieldValue,\n      field: oe.field || rule.fullField\n    };\n  };\n}\n\nfunction deepMerge(target, source) {\n  if (source) {\n    for (var s in source) {\n      if (source.hasOwnProperty(s)) {\n        var value = source[s];\n\n        if (typeof value === 'object' && typeof target[s] === 'object') {\n          target[s] = _extends({}, target[s], value);\n        } else {\n          target[s] = value;\n        }\n      }\n    }\n  }\n\n  return target;\n}\n\nvar required$1 = function required(rule, value, source, errors, options, type) {\n  if (rule.required && (!source.hasOwnProperty(rule.field) || isEmptyValue(value, type || rule.type))) {\n    errors.push(format(options.messages.required, rule.fullField));\n  }\n};\n/**\n *  Rule for validating whitespace.\n *\n *  @param rule The validation rule.\n *  @param value The value of the field on the source object.\n *  @param source The source object being validated.\n *  @param errors An array of errors that this rule may add\n *  validation errors to.\n *  @param options The validation options.\n *  @param options.messages The validation messages.\n */\n\n\nvar whitespace = function whitespace(rule, value, source, errors, options) {\n  if (/^\\s+$/.test(value) || value === '') {\n    errors.push(format(options.messages.whitespace, rule.fullField));\n  }\n}; // https://github.com/kevva/url-regex/blob/master/index.js\n\n\nvar urlReg;\n\nvar getUrlRegex = function getUrlRegex() {\n  if (urlReg) {\n    return urlReg;\n  }\n\n  var word = '[a-fA-F\\\\d:]';\n\n  var b = function b(options) {\n    return options && options.includeBoundaries ? \"(?:(?<=\\\\s|^)(?=\" + word + \")|(?<=\" + word + \")(?=\\\\s|$))\" : '';\n  };\n\n  var v4 = '(?:25[0-5]|2[0-4]\\\\d|1\\\\d\\\\d|[1-9]\\\\d|\\\\d)(?:\\\\.(?:25[0-5]|2[0-4]\\\\d|1\\\\d\\\\d|[1-9]\\\\d|\\\\d)){3}';\n  var v6seg = '[a-fA-F\\\\d]{1,4}';\n  var v6 = (\"\\n(?:\\n(?:\" + v6seg + \":){7}(?:\" + v6seg + \"|:)|                                    // 1:2:3:4:5:6:7::  1:2:3:4:5:6:7:8\\n(?:\" + v6seg + \":){6}(?:\" + v4 + \"|:\" + v6seg + \"|:)|                             // 1:2:3:4:5:6::    1:2:3:4:5:6::8   1:2:3:4:5:6::8  1:2:3:4:5:6::1.2.3.4\\n(?:\" + v6seg + \":){5}(?::\" + v4 + \"|(?::\" + v6seg + \"){1,2}|:)|                   // 1:2:3:4:5::      1:2:3:4:5::7:8   1:2:3:4:5::8    1:2:3:4:5::7:1.2.3.4\\n(?:\" + v6seg + \":){4}(?:(?::\" + v6seg + \"){0,1}:\" + v4 + \"|(?::\" + v6seg + \"){1,3}|:)| // 1:2:3:4::        1:2:3:4::6:7:8   1:2:3:4::8      1:2:3:4::6:7:1.2.3.4\\n(?:\" + v6seg + \":){3}(?:(?::\" + v6seg + \"){0,2}:\" + v4 + \"|(?::\" + v6seg + \"){1,4}|:)| // 1:2:3::          1:2:3::5:6:7:8   1:2:3::8        1:2:3::5:6:7:1.2.3.4\\n(?:\" + v6seg + \":){2}(?:(?::\" + v6seg + \"){0,3}:\" + v4 + \"|(?::\" + v6seg + \"){1,5}|:)| // 1:2::            1:2::4:5:6:7:8   1:2::8          1:2::4:5:6:7:1.2.3.4\\n(?:\" + v6seg + \":){1}(?:(?::\" + v6seg + \"){0,4}:\" + v4 + \"|(?::\" + v6seg + \"){1,6}|:)| // 1::              1::3:4:5:6:7:8   1::8            1::3:4:5:6:7:1.2.3.4\\n(?::(?:(?::\" + v6seg + \"){0,5}:\" + v4 + \"|(?::\" + v6seg + \"){1,7}|:))             // ::2:3:4:5:6:7:8  ::2:3:4:5:6:7:8  ::8             ::1.2.3.4\\n)(?:%[0-9a-zA-Z]{1,})?                                             // %eth0            %1\\n\").replace(/\\s*\\/\\/.*$/gm, '').replace(/\\n/g, '').trim(); // Pre-compile only the exact regexes because adding a global flag make regexes stateful\n\n  var v46Exact = new RegExp(\"(?:^\" + v4 + \"$)|(?:^\" + v6 + \"$)\");\n  var v4exact = new RegExp(\"^\" + v4 + \"$\");\n  var v6exact = new RegExp(\"^\" + v6 + \"$\");\n\n  var ip = function ip(options) {\n    return options && options.exact ? v46Exact : new RegExp(\"(?:\" + b(options) + v4 + b(options) + \")|(?:\" + b(options) + v6 + b(options) + \")\", 'g');\n  };\n\n  ip.v4 = function (options) {\n    return options && options.exact ? v4exact : new RegExp(\"\" + b(options) + v4 + b(options), 'g');\n  };\n\n  ip.v6 = function (options) {\n    return options && options.exact ? v6exact : new RegExp(\"\" + b(options) + v6 + b(options), 'g');\n  };\n\n  var protocol = \"(?:(?:[a-z]+:)?//)\";\n  var auth = '(?:\\\\S+(?::\\\\S*)?@)?';\n  var ipv4 = ip.v4().source;\n  var ipv6 = ip.v6().source;\n  var host = \"(?:(?:[a-z\\\\u00a1-\\\\uffff0-9][-_]*)*[a-z\\\\u00a1-\\\\uffff0-9]+)\";\n  var domain = \"(?:\\\\.(?:[a-z\\\\u00a1-\\\\uffff0-9]-*)*[a-z\\\\u00a1-\\\\uffff0-9]+)*\";\n  var tld = \"(?:\\\\.(?:[a-z\\\\u00a1-\\\\uffff]{2,}))\";\n  var port = '(?::\\\\d{2,5})?';\n  var path = '(?:[/?#][^\\\\s\"]*)?';\n  var regex = \"(?:\" + protocol + \"|www\\\\.)\" + auth + \"(?:localhost|\" + ipv4 + \"|\" + ipv6 + \"|\" + host + domain + tld + \")\" + port + path;\n  urlReg = new RegExp(\"(?:^\" + regex + \"$)\", 'i');\n  return urlReg;\n};\n/* eslint max-len:0 */\n\n\nvar pattern$2 = {\n  // http://emailregex.com/\n  email: /^(([^<>()\\[\\]\\\\.,;:\\s@\"]+(\\.[^<>()\\[\\]\\\\.,;:\\s@\"]+)*)|(\".+\"))@((\\[[0-9]{1,3}\\.[0-9]{1,3}\\.[0-9]{1,3}\\.[0-9]{1,3}])|(([a-zA-Z\\-0-9\\u00A0-\\uD7FF\\uF900-\\uFDCF\\uFDF0-\\uFFEF]+\\.)+[a-zA-Z\\u00A0-\\uD7FF\\uF900-\\uFDCF\\uFDF0-\\uFFEF]{2,}))$/,\n  // url: new RegExp(\n  //   '^(?!mailto:)(?:(?:http|https|ftp)://|//)(?:\\\\S+(?::\\\\S*)?@)?(?:(?:(?:[1-9]\\\\d?|1\\\\d\\\\d|2[01]\\\\d|22[0-3])(?:\\\\.(?:1?\\\\d{1,2}|2[0-4]\\\\d|25[0-5])){2}(?:\\\\.(?:[0-9]\\\\d?|1\\\\d\\\\d|2[0-4]\\\\d|25[0-4]))|(?:(?:[a-z\\\\u00a1-\\\\uffff0-9]+-*)*[a-z\\\\u00a1-\\\\uffff0-9]+)(?:\\\\.(?:[a-z\\\\u00a1-\\\\uffff0-9]+-*)*[a-z\\\\u00a1-\\\\uffff0-9]+)*(?:\\\\.(?:[a-z\\\\u00a1-\\\\uffff]{2,})))|localhost)(?::\\\\d{2,5})?(?:(/|\\\\?|#)[^\\\\s]*)?$',\n  //   'i',\n  // ),\n  hex: /^#?([a-f0-9]{6}|[a-f0-9]{3})$/i\n};\nvar types = {\n  integer: function integer(value) {\n    return types.number(value) && parseInt(value, 10) === value;\n  },\n  \"float\": function float(value) {\n    return types.number(value) && !types.integer(value);\n  },\n  array: function array(value) {\n    return Array.isArray(value);\n  },\n  regexp: function regexp(value) {\n    if (value instanceof RegExp) {\n      return true;\n    }\n\n    try {\n      return !!new RegExp(value);\n    } catch (e) {\n      return false;\n    }\n  },\n  date: function date(value) {\n    return typeof value.getTime === 'function' && typeof value.getMonth === 'function' && typeof value.getYear === 'function' && !isNaN(value.getTime());\n  },\n  number: function number(value) {\n    if (isNaN(value)) {\n      return false;\n    }\n\n    return typeof value === 'number';\n  },\n  object: function object(value) {\n    return typeof value === 'object' && !types.array(value);\n  },\n  method: function method(value) {\n    return typeof value === 'function';\n  },\n  email: function email(value) {\n    return typeof value === 'string' && value.length <= 320 && !!value.match(pattern$2.email);\n  },\n  url: function url(value) {\n    return typeof value === 'string' && value.length <= 2048 && !!value.match(getUrlRegex());\n  },\n  hex: function hex(value) {\n    return typeof value === 'string' && !!value.match(pattern$2.hex);\n  }\n};\n\nvar type$1 = function type(rule, value, source, errors, options) {\n  if (rule.required && value === undefined) {\n    required$1(rule, value, source, errors, options);\n    return;\n  }\n\n  var custom = ['integer', 'float', 'array', 'regexp', 'object', 'method', 'email', 'number', 'date', 'url', 'hex'];\n  var ruleType = rule.type;\n\n  if (custom.indexOf(ruleType) > -1) {\n    if (!types[ruleType](value)) {\n      errors.push(format(options.messages.types[ruleType], rule.fullField, rule.type));\n    } // straight typeof check\n\n  } else if (ruleType && typeof value !== rule.type) {\n    errors.push(format(options.messages.types[ruleType], rule.fullField, rule.type));\n  }\n};\n\nvar range = function range(rule, value, source, errors, options) {\n  var len = typeof rule.len === 'number';\n  var min = typeof rule.min === 'number';\n  var max = typeof rule.max === 'number'; // 正则匹配码点范围从U+010000一直到U+10FFFF的文字（补充平面Supplementary Plane）\n\n  var spRegexp = /[\\uD800-\\uDBFF][\\uDC00-\\uDFFF]/g;\n  var val = value;\n  var key = null;\n  var num = typeof value === 'number';\n  var str = typeof value === 'string';\n  var arr = Array.isArray(value);\n\n  if (num) {\n    key = 'number';\n  } else if (str) {\n    key = 'string';\n  } else if (arr) {\n    key = 'array';\n  } // if the value is not of a supported type for range validation\n  // the validation rule rule should use the\n  // type property to also test for a particular type\n\n\n  if (!key) {\n    return false;\n  }\n\n  if (arr) {\n    val = value.length;\n  }\n\n  if (str) {\n    // 处理码点大于U+010000的文字length属性不准确的bug，如\"𠮷𠮷𠮷\".lenght !== 3\n    val = value.replace(spRegexp, '_').length;\n  }\n\n  if (len) {\n    if (val !== rule.len) {\n      errors.push(format(options.messages[key].len, rule.fullField, rule.len));\n    }\n  } else if (min && !max && val < rule.min) {\n    errors.push(format(options.messages[key].min, rule.fullField, rule.min));\n  } else if (max && !min && val > rule.max) {\n    errors.push(format(options.messages[key].max, rule.fullField, rule.max));\n  } else if (min && max && (val < rule.min || val > rule.max)) {\n    errors.push(format(options.messages[key].range, rule.fullField, rule.min, rule.max));\n  }\n};\n\nvar ENUM$1 = 'enum';\n\nvar enumerable$1 = function enumerable(rule, value, source, errors, options) {\n  rule[ENUM$1] = Array.isArray(rule[ENUM$1]) ? rule[ENUM$1] : [];\n\n  if (rule[ENUM$1].indexOf(value) === -1) {\n    errors.push(format(options.messages[ENUM$1], rule.fullField, rule[ENUM$1].join(', ')));\n  }\n};\n\nvar pattern$1 = function pattern(rule, value, source, errors, options) {\n  if (rule.pattern) {\n    if (rule.pattern instanceof RegExp) {\n      // if a RegExp instance is passed, reset `lastIndex` in case its `global`\n      // flag is accidentally set to `true`, which in a validation scenario\n      // is not necessary and the result might be misleading\n      rule.pattern.lastIndex = 0;\n\n      if (!rule.pattern.test(value)) {\n        errors.push(format(options.messages.pattern.mismatch, rule.fullField, value, rule.pattern));\n      }\n    } else if (typeof rule.pattern === 'string') {\n      var _pattern = new RegExp(rule.pattern);\n\n      if (!_pattern.test(value)) {\n        errors.push(format(options.messages.pattern.mismatch, rule.fullField, value, rule.pattern));\n      }\n    }\n  }\n};\n\nvar rules = {\n  required: required$1,\n  whitespace: whitespace,\n  type: type$1,\n  range: range,\n  \"enum\": enumerable$1,\n  pattern: pattern$1\n};\n\nvar string = function string(rule, value, callback, source, options) {\n  var errors = [];\n  var validate = rule.required || !rule.required && source.hasOwnProperty(rule.field);\n\n  if (validate) {\n    if (isEmptyValue(value, 'string') && !rule.required) {\n      return callback();\n    }\n\n    rules.required(rule, value, source, errors, options, 'string');\n\n    if (!isEmptyValue(value, 'string')) {\n      rules.type(rule, value, source, errors, options);\n      rules.range(rule, value, source, errors, options);\n      rules.pattern(rule, value, source, errors, options);\n\n      if (rule.whitespace === true) {\n        rules.whitespace(rule, value, source, errors, options);\n      }\n    }\n  }\n\n  callback(errors);\n};\n\nvar method = function method(rule, value, callback, source, options) {\n  var errors = [];\n  var validate = rule.required || !rule.required && source.hasOwnProperty(rule.field);\n\n  if (validate) {\n    if (isEmptyValue(value) && !rule.required) {\n      return callback();\n    }\n\n    rules.required(rule, value, source, errors, options);\n\n    if (value !== undefined) {\n      rules.type(rule, value, source, errors, options);\n    }\n  }\n\n  callback(errors);\n};\n\nvar number = function number(rule, value, callback, source, options) {\n  var errors = [];\n  var validate = rule.required || !rule.required && source.hasOwnProperty(rule.field);\n\n  if (validate) {\n    if (value === '') {\n      value = undefined;\n    }\n\n    if (isEmptyValue(value) && !rule.required) {\n      return callback();\n    }\n\n    rules.required(rule, value, source, errors, options);\n\n    if (value !== undefined) {\n      rules.type(rule, value, source, errors, options);\n      rules.range(rule, value, source, errors, options);\n    }\n  }\n\n  callback(errors);\n};\n\nvar _boolean = function _boolean(rule, value, callback, source, options) {\n  var errors = [];\n  var validate = rule.required || !rule.required && source.hasOwnProperty(rule.field);\n\n  if (validate) {\n    if (isEmptyValue(value) && !rule.required) {\n      return callback();\n    }\n\n    rules.required(rule, value, source, errors, options);\n\n    if (value !== undefined) {\n      rules.type(rule, value, source, errors, options);\n    }\n  }\n\n  callback(errors);\n};\n\nvar regexp = function regexp(rule, value, callback, source, options) {\n  var errors = [];\n  var validate = rule.required || !rule.required && source.hasOwnProperty(rule.field);\n\n  if (validate) {\n    if (isEmptyValue(value) && !rule.required) {\n      return callback();\n    }\n\n    rules.required(rule, value, source, errors, options);\n\n    if (!isEmptyValue(value)) {\n      rules.type(rule, value, source, errors, options);\n    }\n  }\n\n  callback(errors);\n};\n\nvar integer = function integer(rule, value, callback, source, options) {\n  var errors = [];\n  var validate = rule.required || !rule.required && source.hasOwnProperty(rule.field);\n\n  if (validate) {\n    if (isEmptyValue(value) && !rule.required) {\n      return callback();\n    }\n\n    rules.required(rule, value, source, errors, options);\n\n    if (value !== undefined) {\n      rules.type(rule, value, source, errors, options);\n      rules.range(rule, value, source, errors, options);\n    }\n  }\n\n  callback(errors);\n};\n\nvar floatFn = function floatFn(rule, value, callback, source, options) {\n  var errors = [];\n  var validate = rule.required || !rule.required && source.hasOwnProperty(rule.field);\n\n  if (validate) {\n    if (isEmptyValue(value) && !rule.required) {\n      return callback();\n    }\n\n    rules.required(rule, value, source, errors, options);\n\n    if (value !== undefined) {\n      rules.type(rule, value, source, errors, options);\n      rules.range(rule, value, source, errors, options);\n    }\n  }\n\n  callback(errors);\n};\n\nvar array = function array(rule, value, callback, source, options) {\n  var errors = [];\n  var validate = rule.required || !rule.required && source.hasOwnProperty(rule.field);\n\n  if (validate) {\n    if ((value === undefined || value === null) && !rule.required) {\n      return callback();\n    }\n\n    rules.required(rule, value, source, errors, options, 'array');\n\n    if (value !== undefined && value !== null) {\n      rules.type(rule, value, source, errors, options);\n      rules.range(rule, value, source, errors, options);\n    }\n  }\n\n  callback(errors);\n};\n\nvar object = function object(rule, value, callback, source, options) {\n  var errors = [];\n  var validate = rule.required || !rule.required && source.hasOwnProperty(rule.field);\n\n  if (validate) {\n    if (isEmptyValue(value) && !rule.required) {\n      return callback();\n    }\n\n    rules.required(rule, value, source, errors, options);\n\n    if (value !== undefined) {\n      rules.type(rule, value, source, errors, options);\n    }\n  }\n\n  callback(errors);\n};\n\nvar ENUM = 'enum';\n\nvar enumerable = function enumerable(rule, value, callback, source, options) {\n  var errors = [];\n  var validate = rule.required || !rule.required && source.hasOwnProperty(rule.field);\n\n  if (validate) {\n    if (isEmptyValue(value) && !rule.required) {\n      return callback();\n    }\n\n    rules.required(rule, value, source, errors, options);\n\n    if (value !== undefined) {\n      rules[ENUM](rule, value, source, errors, options);\n    }\n  }\n\n  callback(errors);\n};\n\nvar pattern = function pattern(rule, value, callback, source, options) {\n  var errors = [];\n  var validate = rule.required || !rule.required && source.hasOwnProperty(rule.field);\n\n  if (validate) {\n    if (isEmptyValue(value, 'string') && !rule.required) {\n      return callback();\n    }\n\n    rules.required(rule, value, source, errors, options);\n\n    if (!isEmptyValue(value, 'string')) {\n      rules.pattern(rule, value, source, errors, options);\n    }\n  }\n\n  callback(errors);\n};\n\nvar date = function date(rule, value, callback, source, options) {\n  // console.log('integer rule called %j', rule);\n  var errors = [];\n  var validate = rule.required || !rule.required && source.hasOwnProperty(rule.field); // console.log('validate on %s value', value);\n\n  if (validate) {\n    if (isEmptyValue(value, 'date') && !rule.required) {\n      return callback();\n    }\n\n    rules.required(rule, value, source, errors, options);\n\n    if (!isEmptyValue(value, 'date')) {\n      var dateObject;\n\n      if (value instanceof Date) {\n        dateObject = value;\n      } else {\n        dateObject = new Date(value);\n      }\n\n      rules.type(rule, dateObject, source, errors, options);\n\n      if (dateObject) {\n        rules.range(rule, dateObject.getTime(), source, errors, options);\n      }\n    }\n  }\n\n  callback(errors);\n};\n\nvar required = function required(rule, value, callback, source, options) {\n  var errors = [];\n  var type = Array.isArray(value) ? 'array' : typeof value;\n  rules.required(rule, value, source, errors, options, type);\n  callback(errors);\n};\n\nvar type = function type(rule, value, callback, source, options) {\n  var ruleType = rule.type;\n  var errors = [];\n  var validate = rule.required || !rule.required && source.hasOwnProperty(rule.field);\n\n  if (validate) {\n    if (isEmptyValue(value, ruleType) && !rule.required) {\n      return callback();\n    }\n\n    rules.required(rule, value, source, errors, options, ruleType);\n\n    if (!isEmptyValue(value, ruleType)) {\n      rules.type(rule, value, source, errors, options);\n    }\n  }\n\n  callback(errors);\n};\n\nvar any = function any(rule, value, callback, source, options) {\n  var errors = [];\n  var validate = rule.required || !rule.required && source.hasOwnProperty(rule.field);\n\n  if (validate) {\n    if (isEmptyValue(value) && !rule.required) {\n      return callback();\n    }\n\n    rules.required(rule, value, source, errors, options);\n  }\n\n  callback(errors);\n};\n\nvar validators = {\n  string: string,\n  method: method,\n  number: number,\n  \"boolean\": _boolean,\n  regexp: regexp,\n  integer: integer,\n  \"float\": floatFn,\n  array: array,\n  object: object,\n  \"enum\": enumerable,\n  pattern: pattern,\n  date: date,\n  url: type,\n  hex: type,\n  email: type,\n  required: required,\n  any: any\n};\n\nfunction newMessages() {\n  return {\n    \"default\": 'Validation error on field %s',\n    required: '%s is required',\n    \"enum\": '%s must be one of %s',\n    whitespace: '%s cannot be empty',\n    date: {\n      format: '%s date %s is invalid for format %s',\n      parse: '%s date could not be parsed, %s is invalid ',\n      invalid: '%s date %s is invalid'\n    },\n    types: {\n      string: '%s is not a %s',\n      method: '%s is not a %s (function)',\n      array: '%s is not an %s',\n      object: '%s is not an %s',\n      number: '%s is not a %s',\n      date: '%s is not a %s',\n      \"boolean\": '%s is not a %s',\n      integer: '%s is not an %s',\n      \"float\": '%s is not a %s',\n      regexp: '%s is not a valid %s',\n      email: '%s is not a valid %s',\n      url: '%s is not a valid %s',\n      hex: '%s is not a valid %s'\n    },\n    string: {\n      len: '%s must be exactly %s characters',\n      min: '%s must be at least %s characters',\n      max: '%s cannot be longer than %s characters',\n      range: '%s must be between %s and %s characters'\n    },\n    number: {\n      len: '%s must equal %s',\n      min: '%s cannot be less than %s',\n      max: '%s cannot be greater than %s',\n      range: '%s must be between %s and %s'\n    },\n    array: {\n      len: '%s must be exactly %s in length',\n      min: '%s cannot be less than %s in length',\n      max: '%s cannot be greater than %s in length',\n      range: '%s must be between %s and %s in length'\n    },\n    pattern: {\n      mismatch: '%s value %s does not match pattern %s'\n    },\n    clone: function clone() {\n      var cloned = JSON.parse(JSON.stringify(this));\n      cloned.clone = this.clone;\n      return cloned;\n    }\n  };\n}\n\nvar messages = newMessages();\n/**\n *  Encapsulates a validation schema.\n *\n *  @param descriptor An object declaring validation rules\n *  for this schema.\n */\n\nvar Schema = /*#__PURE__*/function () {\n  // ========================= Static =========================\n  // ======================== Instance ========================\n  function Schema(descriptor) {\n    this.rules = null;\n    this._messages = messages;\n    this.define(descriptor);\n  }\n\n  var _proto = Schema.prototype;\n\n  _proto.define = function define(rules) {\n    var _this = this;\n\n    if (!rules) {\n      throw new Error('Cannot configure a schema with no rules');\n    }\n\n    if (typeof rules !== 'object' || Array.isArray(rules)) {\n      throw new Error('Rules must be an object');\n    }\n\n    this.rules = {};\n    Object.keys(rules).forEach(function (name) {\n      var item = rules[name];\n      _this.rules[name] = Array.isArray(item) ? item : [item];\n    });\n  };\n\n  _proto.messages = function messages(_messages) {\n    if (_messages) {\n      this._messages = deepMerge(newMessages(), _messages);\n    }\n\n    return this._messages;\n  };\n\n  _proto.validate = function validate(source_, o, oc) {\n    var _this2 = this;\n\n    if (o === void 0) {\n      o = {};\n    }\n\n    if (oc === void 0) {\n      oc = function oc() {};\n    }\n\n    var source = source_;\n    var options = o;\n    var callback = oc;\n\n    if (typeof options === 'function') {\n      callback = options;\n      options = {};\n    }\n\n    if (!this.rules || Object.keys(this.rules).length === 0) {\n      if (callback) {\n        callback(null, source);\n      }\n\n      return Promise.resolve(source);\n    }\n\n    function complete(results) {\n      var errors = [];\n      var fields = {};\n\n      function add(e) {\n        if (Array.isArray(e)) {\n          var _errors;\n\n          errors = (_errors = errors).concat.apply(_errors, e);\n        } else {\n          errors.push(e);\n        }\n      }\n\n      for (var i = 0; i < results.length; i++) {\n        add(results[i]);\n      }\n\n      if (!errors.length) {\n        callback(null, source);\n      } else {\n        fields = convertFieldsError(errors);\n        callback(errors, fields);\n      }\n    }\n\n    if (options.messages) {\n      var messages$1 = this.messages();\n\n      if (messages$1 === messages) {\n        messages$1 = newMessages();\n      }\n\n      deepMerge(messages$1, options.messages);\n      options.messages = messages$1;\n    } else {\n      options.messages = this.messages();\n    }\n\n    var series = {};\n    var keys = options.keys || Object.keys(this.rules);\n    keys.forEach(function (z) {\n      var arr = _this2.rules[z];\n      var value = source[z];\n      arr.forEach(function (r) {\n        var rule = r;\n\n        if (typeof rule.transform === 'function') {\n          if (source === source_) {\n            source = _extends({}, source);\n          }\n\n          value = source[z] = rule.transform(value);\n        }\n\n        if (typeof rule === 'function') {\n          rule = {\n            validator: rule\n          };\n        } else {\n          rule = _extends({}, rule);\n        } // Fill validator. Skip if nothing need to validate\n\n\n        rule.validator = _this2.getValidationMethod(rule);\n\n        if (!rule.validator) {\n          return;\n        }\n\n        rule.field = z;\n        rule.fullField = rule.fullField || z;\n        rule.type = _this2.getType(rule);\n        series[z] = series[z] || [];\n        series[z].push({\n          rule: rule,\n          value: value,\n          source: source,\n          field: z\n        });\n      });\n    });\n    var errorFields = {};\n    return asyncMap(series, options, function (data, doIt) {\n      var rule = data.rule;\n      var deep = (rule.type === 'object' || rule.type === 'array') && (typeof rule.fields === 'object' || typeof rule.defaultField === 'object');\n      deep = deep && (rule.required || !rule.required && data.value);\n      rule.field = data.field;\n\n      function addFullField(key, schema) {\n        return _extends({}, schema, {\n          fullField: rule.fullField + \".\" + key,\n          fullFields: rule.fullFields ? [].concat(rule.fullFields, [key]) : [key]\n        });\n      }\n\n      function cb(e) {\n        if (e === void 0) {\n          e = [];\n        }\n\n        var errorList = Array.isArray(e) ? e : [e];\n\n        if (!options.suppressWarning && errorList.length) {\n          Schema.warning('async-validator:', errorList);\n        }\n\n        if (errorList.length && rule.message !== undefined) {\n          errorList = [].concat(rule.message);\n        } // Fill error info\n\n\n        var filledErrors = errorList.map(complementError(rule, source));\n\n        if (options.first && filledErrors.length) {\n          errorFields[rule.field] = 1;\n          return doIt(filledErrors);\n        }\n\n        if (!deep) {\n          doIt(filledErrors);\n        } else {\n          // if rule is required but the target object\n          // does not exist fail at the rule level and don't\n          // go deeper\n          if (rule.required && !data.value) {\n            if (rule.message !== undefined) {\n              filledErrors = [].concat(rule.message).map(complementError(rule, source));\n            } else if (options.error) {\n              filledErrors = [options.error(rule, format(options.messages.required, rule.field))];\n            }\n\n            return doIt(filledErrors);\n          }\n\n          var fieldsSchema = {};\n\n          if (rule.defaultField) {\n            Object.keys(data.value).map(function (key) {\n              fieldsSchema[key] = rule.defaultField;\n            });\n          }\n\n          fieldsSchema = _extends({}, fieldsSchema, data.rule.fields);\n          var paredFieldsSchema = {};\n          Object.keys(fieldsSchema).forEach(function (field) {\n            var fieldSchema = fieldsSchema[field];\n            var fieldSchemaList = Array.isArray(fieldSchema) ? fieldSchema : [fieldSchema];\n            paredFieldsSchema[field] = fieldSchemaList.map(addFullField.bind(null, field));\n          });\n          var schema = new Schema(paredFieldsSchema);\n          schema.messages(options.messages);\n\n          if (data.rule.options) {\n            data.rule.options.messages = options.messages;\n            data.rule.options.error = options.error;\n          }\n\n          schema.validate(data.value, data.rule.options || options, function (errs) {\n            var finalErrors = [];\n\n            if (filledErrors && filledErrors.length) {\n              finalErrors.push.apply(finalErrors, filledErrors);\n            }\n\n            if (errs && errs.length) {\n              finalErrors.push.apply(finalErrors, errs);\n            }\n\n            doIt(finalErrors.length ? finalErrors : null);\n          });\n        }\n      }\n\n      var res;\n\n      if (rule.asyncValidator) {\n        res = rule.asyncValidator(rule, data.value, cb, data.source, options);\n      } else if (rule.validator) {\n        try {\n          res = rule.validator(rule, data.value, cb, data.source, options);\n        } catch (error) {\n          console.error == null ? void 0 : console.error(error); // rethrow to report error\n\n          if (!options.suppressValidatorError) {\n            setTimeout(function () {\n              throw error;\n            }, 0);\n          }\n\n          cb(error.message);\n        }\n\n        if (res === true) {\n          cb();\n        } else if (res === false) {\n          cb(typeof rule.message === 'function' ? rule.message(rule.fullField || rule.field) : rule.message || (rule.fullField || rule.field) + \" fails\");\n        } else if (res instanceof Array) {\n          cb(res);\n        } else if (res instanceof Error) {\n          cb(res.message);\n        }\n      }\n\n      if (res && res.then) {\n        res.then(function () {\n          return cb();\n        }, function (e) {\n          return cb(e);\n        });\n      }\n    }, function (results) {\n      complete(results);\n    }, source);\n  };\n\n  _proto.getType = function getType(rule) {\n    if (rule.type === undefined && rule.pattern instanceof RegExp) {\n      rule.type = 'pattern';\n    }\n\n    if (typeof rule.validator !== 'function' && rule.type && !validators.hasOwnProperty(rule.type)) {\n      throw new Error(format('Unknown rule type %s', rule.type));\n    }\n\n    return rule.type || 'string';\n  };\n\n  _proto.getValidationMethod = function getValidationMethod(rule) {\n    if (typeof rule.validator === 'function') {\n      return rule.validator;\n    }\n\n    var keys = Object.keys(rule);\n    var messageIndex = keys.indexOf('message');\n\n    if (messageIndex !== -1) {\n      keys.splice(messageIndex, 1);\n    }\n\n    if (keys.length === 1 && keys[0] === 'required') {\n      return validators.required;\n    }\n\n    return validators[this.getType(rule)] || undefined;\n  };\n\n  return Schema;\n}();\n\nSchema.register = function register(type, validator) {\n  if (typeof validator !== 'function') {\n    throw new Error('Cannot register a validator by type, validator is not a function');\n  }\n\n  validators[type] = validator;\n};\n\nSchema.warning = warning;\nSchema.messages = messages;\nSchema.validators = validators;\nexport { Schema as default };","map":{"version":3,"sources":["../../src/util.ts","../../src/rule/required.ts","../../src/rule/whitespace.ts","../../src/rule/url.ts","../../src/rule/type.ts","../../src/rule/range.ts","../../src/rule/enum.ts","../../src/rule/pattern.ts","../../src/rule/index.ts","../../src/validator/string.ts","../../src/validator/method.ts","../../src/validator/number.ts","../../src/validator/boolean.ts","../../src/validator/regexp.ts","../../src/validator/integer.ts","../../src/validator/float.ts","../../src/validator/array.ts","../../src/validator/object.ts","../../src/validator/enum.ts","../../src/validator/pattern.ts","../../src/validator/date.ts","../../src/validator/required.ts","../../src/validator/type.ts","../../src/validator/any.ts","../../src/validator/index.ts","../../src/messages.ts","../../src/index.ts"],"names":["formatRegExp","warning","process","console","errors","fields","field","error","args","i","len","template","str","x","String","Number","JSON","type","value","Array","isNativeStringType","results","total","arrLength","arr","callback","func","index","original","next","ret","Object","objArr","AsyncValidationError","option","pending","reject","convertFieldsError","resolve","flattenArr","flattenObjArr","asyncSerialArray","firstFields","objArrKeys","objArrLength","asyncParallelArray","obj","v","path","rule","fieldValue","getValue","source","oe","isErrorObj","message","fullField","target","required","isEmptyValue","format","options","whitespace","word","b","v4","v6seg","v6","v46Exact","v4exact","v6exact","ip","protocol","auth","ipv4","ipv6","host","domain","tld","port","regex","urlReg","pattern","email","hex","types","integer","parseInt","array","regexp","date","isNaN","number","object","method","url","getUrlRegex","custom","ruleType","range","min","max","spRegexp","val","key","num","ENUM","enumerable","_pattern","string","validate","rules","boolean","floatFn","dateObject","any","parse","invalid","mismatch","clone","cloned","messages","newMessages","Schema","register","validators","defaultMessages","_messages","define","item","deepMerge","source_","o","oc","Promise","add","series","keys","validator","z","errorFields","asyncMap","data","deep","fullFields","e","errorList","filledErrors","complementError","doIt","fieldsSchema","paredFieldsSchema","fieldSchema","fieldSchemaList","addFullField","schema","finalErrors","errs","res","setTimeout","cb","complete","getType","getValidationMethod","messageIndex"],"mappings":";;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AAAA;;;AAaA,IAAMA,YAAY,GAAlB,UAAA;;AAIO,IAAIC,OAAwD,GAAG,SAAA,OAAA,GAAM,CAArE,CAAA,C,CAAA;;;AAGP,IACE,OAAA,OAAA,KAAA,WAAA,IACAC,OAAO,CADP,GAAA,IAEAA,OAAO,CAAPA,GAAAA,CAAAA,QAAAA,KAFA,YAAA,IAGA,OAAA,MAAA,KAHA,WAAA,IAIA,OAAA,QAAA,KALF,WAAA,EAME;EACAD,OAAO,GAAG,SAAA,OAAA,CAAA,IAAA,EAAA,MAAA,EAAkB;IAC1B,IACE,OAAA,OAAA,KAAA,WAAA,IACAE,OAAO,CADP,IAAA,IAEA,OAAA,0BAAA,KAHF,WAAA,EAIE;MACA,IAAI,MAAM,CAAN,KAAA,CAAa,UAAA,CAAA,EAAC;QAAA,OAAI,OAAA,CAAA,KAAJ,QAAA;MAAlB,CAAI,CAAJ,EAA8C;QAC5CA,OAAO,CAAPA,IAAAA,CAAAA,IAAAA,EAAAA,MAAAA;MACD;IACF;EATHF,CAAAA;AAWD;;AAEM,SAAA,kBAAA,CAAA,MAAA,EAE4B;EACjC,IAAI,CAAA,MAAA,IAAW,CAACG,MAAM,CAAtB,MAAA,EAA+B,OAAA,IAAA;EAC/B,IAAMC,MAAM,GAAZ,EAAA;EACAD,MAAM,CAANA,OAAAA,CAAe,UAAA,KAAA,EAAS;IACtB,IAAME,KAAK,GAAGC,KAAK,CAAnB,KAAA;IACAF,MAAM,CAANA,KAAM,CAANA,GAAgBA,MAAM,CAANA,KAAM,CAANA,IAAhBA,EAAAA;IACAA,MAAM,CAANA,KAAM,CAANA,CAAAA,IAAAA,CAAAA,KAAAA;EAHFD,CAAAA;EAKA,OAAA,MAAA;AACD;;AAEM,SAAA,MAAA,CAAA,QAAA,EAGG;EAAA,KAAA,IAAA,IAAA,GAAA,SAAA,CAAA,MAAA,EADLI,IACK,GAAA,IAAA,KAAA,CAAA,IAAA,GAAA,CAAA,GAAA,IAAA,GAAA,CAAA,GAAA,CAAA,CAAA,EAAA,IAAA,GAAA,CAAA,EAAA,IAAA,GAAA,IAAA,EAAA,IAAA,EAAA,EAAA;IADLA,IACK,CAAA,IAAA,GAAA,CAAA,CADLA,GACK,SAAA,CAAA,IAAA,CADLA;EACK;;EACR,IAAIC,CAAC,GAAL,CAAA;EACA,IAAMC,GAAG,GAAGF,IAAI,CAAhB,MAAA;;EACA,IAAI,OAAA,QAAA,KAAJ,UAAA,EAAoC;IAClC,OAAOG,QAAQ,CAARA,KAAAA,CAAAA,IAAAA,EAAP,IAAOA,CAAP;EACD;;EACD,IAAI,OAAA,QAAA,KAAJ,QAAA,EAAkC;IAChC,IAAIC,GAAG,GAAG,QAAQ,CAAR,OAAA,CAAA,YAAA,EAA+B,UAAA,CAAA,EAAK;MAC5C,IAAIC,CAAC,KAAL,IAAA,EAAgB;QACd,OAAA,GAAA;MACD;;MACD,IAAIJ,CAAC,IAAL,GAAA,EAAc;QACZ,OAAA,CAAA;MACD;;MACD,QAAA,CAAA;QACE,KAAA,IAAA;UACE,OAAOK,MAAM,CAACN,IAAI,CAACC,CAAnB,EAAkB,CAAL,CAAb;;QACF,KAAA,IAAA;UACE,OAAQM,MAAM,CAACP,IAAI,CAACC,CAApB,EAAmB,CAAL,CAAd;;QACF,KAAA,IAAA;UACE,IAAI;YACF,OAAOO,IAAI,CAAJA,SAAAA,CAAeR,IAAI,CAACC,CAA3B,EAA0B,CAAnBO,CAAP;UADF,CAAA,CAEE,OAAA,CAAA,EAAU;YACV,OAAA,YAAA;UACD;;UACD;;QACF;UACE,OAAA,CAAA;MAbJ;IAPF,CAAU,CAAV;IAuBA,OAAA,GAAA;EACD;;EACD,OAAA,QAAA;AACD;;AAED,SAAA,kBAAA,CAAA,IAAA,EAA0C;EACxC,OACEC,IAAI,KAAJA,QAAAA,IACAA,IAAI,KADJA,KAAAA,IAEAA,IAAI,KAFJA,KAAAA,IAGAA,IAAI,KAHJA,OAAAA,IAIAA,IAAI,KAJJA,MAAAA,IAKAA,IAAI,KANN,SAAA;AAQD;;AAEM,SAAA,YAAA,CAAA,KAAA,EAAA,IAAA,EAAmD;EACxD,IAAIC,KAAK,KAALA,SAAAA,IAAuBA,KAAK,KAAhC,IAAA,EAA2C;IACzC,OAAA,IAAA;EACD;;EACD,IAAID,IAAI,KAAJA,OAAAA,IAAoBE,KAAK,CAALA,OAAAA,CAApBF,KAAoBE,CAApBF,IAA4C,CAACC,KAAK,CAAtD,MAAA,EAA+D;IAC7D,OAAA,IAAA;EACD;;EACD,IAAIE,kBAAkB,CAAlBA,IAAkB,CAAlBA,IAA4B,OAAA,KAAA,KAA5BA,QAAAA,IAAyD,CAA7D,KAAA,EAAqE;IACnE,OAAA,IAAA;EACD;;EACD,OAAA,KAAA;AACD;;AAMD,SAAA,kBAAA,CAAA,GAAA,EAAA,IAAA,EAAA,QAAA,EAIE;EACA,IAAMC,OAAwB,GAA9B,EAAA;EACA,IAAIC,KAAK,GAAT,CAAA;EACA,IAAMC,SAAS,GAAGC,GAAG,CAArB,MAAA;;EAEA,SAAA,KAAA,CAAA,MAAA,EAAwC;IACtCH,OAAO,CAAPA,IAAAA,CAAAA,KAAAA,CAAAA,OAAAA,EAAiBjB,MAAM,IAAvBiB,EAAAA;IACAC,KAAK;;IACL,IAAIA,KAAK,KAAT,SAAA,EAAyB;MACvBG,QAAQ,CAARA,OAAQ,CAARA;IACD;EACF;;EAEDD,GAAG,CAAHA,OAAAA,CAAY,UAAA,CAAA,EAAK;IACfE,IAAI,CAAA,CAAA,EAAJA,KAAI,CAAJA;EADFF,CAAAA;AAGD;;AAED,SAAA,gBAAA,CAAA,GAAA,EAAA,IAAA,EAAA,QAAA,EAIE;EACA,IAAIG,KAAK,GAAT,CAAA;EACA,IAAMJ,SAAS,GAAGC,GAAG,CAArB,MAAA;;EAEA,SAAA,IAAA,CAAA,MAAA,EAAuC;IACrC,IAAIpB,MAAM,IAAIA,MAAM,CAApB,MAAA,EAA6B;MAC3BqB,QAAQ,CAARA,MAAQ,CAARA;MACA;IACD;;IACD,IAAMG,QAAQ,GAAd,KAAA;IACAD,KAAK,GAAGA,KAAK,GAAbA,CAAAA;;IACA,IAAIC,QAAQ,GAAZ,SAAA,EAA0B;MACxBF,IAAI,CAACF,GAAG,CAAJ,QAAI,CAAJ,EAAJE,IAAI,CAAJA;IADF,CAAA,MAEO;MACLD,QAAQ,CAARA,EAAQ,CAARA;IACD;EACF;;EAEDI,IAAI,CAAJA,EAAI,CAAJA;AACD;;AAED,SAAA,aAAA,CAAA,MAAA,EAAmE;EACjE,IAAMC,GAAuB,GAA7B,EAAA;EACAC,MAAM,CAANA,IAAAA,CAAAA,MAAAA,EAAAA,OAAAA,CAA4B,UAAA,CAAA,EAAK;IAC/BD,GAAG,CAAHA,IAAAA,CAAAA,KAAAA,CAAAA,GAAAA,EAAaE,MAAM,CAANA,CAAM,CAANA,IAAbF,EAAAA;EADFC,CAAAA;EAGA,OAAA,GAAA;AACD;;AAED,IAAaE,oBAAb,GAAA,aAAA,UAAA,MAAA,EAAA;EAAA,cAAA,CAAA,oBAAA,EAAA,MAAA,CAAA;;EAIE,SACE7B,oBADF,CAAA,MAAA,EAAA,MAAA,EAGE;IAAA,IAAA,KAAA;;IACA,KAAA,GAAA,MAAA,CAAA,IAAA,CAAA,IAAA,EAAA,wBAAA,KAAA,IAAA;IACA,KAAKA,CAAL,MAAA,GAAA,MAAA;IACA,KAAKC,CAAL,MAAA,GAAA,MAAA;IAHA,OAAA,KAAA;EAID;;EAXH,OAAA,oBAAA;AAAA,CAAA,EAAA,aAAA,gBAAA,CAAA,KAAA,CAAA,CAAA;;AAmBO,SAAA,QAAA,CAAA,MAAA,EAAA,MAAA,EAAA,IAAA,EAAA,QAAA,EAAA,MAAA,EAMY;EACjB,IAAI6B,MAAM,CAAV,KAAA,EAAkB;IAChB,IAAMC,QAAO,GAAG,IAAA,OAAA,CAAoB,UAAA,OAAA,EAAA,MAAA,EAAqB;MACvD,IAAMN,IAAI,GAAG,SAAPA,IAAO,CAAA,MAAA,EAA6B;QACxCJ,QAAQ,CAARA,MAAQ,CAARA;QACA,OAAOrB,MAAM,CAANA,MAAAA,GACHgC,MAAM,CAAC,IAAA,oBAAA,CAAA,MAAA,EAAiCC,kBAAkB,CADvDjC,MACuD,CAAnD,CAAD,CADHA,GAEHkC,OAAO,CAFX,MAEW,CAFX;MAFF,CAAA;;MAMA,IAAMC,UAAU,GAAGC,aAAa,CAAhC,MAAgC,CAAhC;MACAC,gBAAgB,CAAA,UAAA,EAAA,IAAA,EAAhBA,IAAgB,CAAhBA;IARF,CAAgB,CAAhB;;IAUAN,QAAO,CAAPA,OAAO,CAAPA,CAAc,UAAA,CAAA,EAAC;MAAA,OAAA,CAAA;IAAfA,CAAAA;;IACA,OAAA,QAAA;EACD;;EACD,IAAMO,WAAW,GACfR,MAAM,CAANA,WAAAA,KAAAA,IAAAA,GACIH,MAAM,CAANA,IAAAA,CADJG,MACIH,CADJG,GAEIA,MAAM,CAANA,WAAAA,IAHN,EAAA;EAKA,IAAMS,UAAU,GAAGZ,MAAM,CAANA,IAAAA,CAAnB,MAAmBA,CAAnB;EACA,IAAMa,YAAY,GAAGD,UAAU,CAA/B,MAAA;EACA,IAAIrB,KAAK,GAAT,CAAA;EACA,IAAMD,OAAwB,GAA9B,EAAA;EACA,IAAMc,OAAO,GAAG,IAAA,OAAA,CAAoB,UAAA,OAAA,EAAA,MAAA,EAAqB;IACvD,IAAMN,IAAI,GAAG,SAAPA,IAAO,CAAA,MAAA,EAA6B;MACxCR,OAAO,CAAPA,IAAAA,CAAAA,KAAAA,CAAAA,OAAAA,EAAAA,MAAAA;MACAC,KAAK;;MACL,IAAIA,KAAK,KAAT,YAAA,EAA4B;QAC1BG,QAAQ,CAARA,OAAQ,CAARA;QACA,OAAOJ,OAAO,CAAPA,MAAAA,GACHe,MAAM,CACJ,IAAA,oBAAA,CAAA,OAAA,EAAkCC,kBAAkB,CAFnDhB,OAEmD,CAApD,CADI,CADHA,GAIHiB,OAAO,CAJX,MAIW,CAJX;MAKD;IAVH,CAAA;;IAYA,IAAI,CAACK,UAAU,CAAf,MAAA,EAAwB;MACtBlB,QAAQ,CAARA,OAAQ,CAARA;MACAa,OAAO,CAAPA,MAAO,CAAPA;IACD;;IACDK,UAAU,CAAVA,OAAAA,CAAmB,UAAA,GAAA,EAAO;MACxB,IAAMnB,GAAG,GAAGQ,MAAM,CAAlB,GAAkB,CAAlB;;MACA,IAAIU,WAAW,CAAXA,OAAAA,CAAAA,GAAAA,MAA6B,CAAjC,CAAA,EAAqC;QACnCD,gBAAgB,CAAA,GAAA,EAAA,IAAA,EAAhBA,IAAgB,CAAhBA;MADF,CAAA,MAEO;QACLI,kBAAkB,CAAA,GAAA,EAAA,IAAA,EAAlBA,IAAkB,CAAlBA;MACD;IANHF,CAAAA;EAjBF,CAAgB,CAAhB;EA0BAR,OAAO,CAAPA,OAAO,CAAPA,CAAc,UAAA,CAAA,EAAC;IAAA,OAAA,CAAA;EAAfA,CAAAA;EACA,OAAA,OAAA;AACD;;AAED,SAAA,UAAA,CAAA,GAAA,EAEwB;EACtB,OAAO,CAAC,EAAEW,GAAG,IAAKA,GAAD,CAAA,OAACA,KAAlB,SAAQ,CAAR;AACD;;AAED,SAAA,QAAA,CAAA,KAAA,EAAA,IAAA,EAAiD;EAC/C,IAAIC,CAAC,GAAL,KAAA;;EACA,KAAK,IAAItC,CAAC,GAAV,CAAA,EAAgBA,CAAC,GAAGuC,IAAI,CAAxB,MAAA,EAAiCvC,CAAjC,EAAA,EAAsC;IACpC,IAAIsC,CAAC,IAAL,SAAA,EAAoB;MAClB,OAAA,CAAA;IACD;;IACDA,CAAC,GAAGA,CAAC,CAACC,IAAI,CAAVD,CAAU,CAAL,CAALA;EACD;;EACD,OAAA,CAAA;AACD;;AAEM,SAAA,eAAA,CAAA,IAAA,EAAA,MAAA,EAAiE;EACtE,OAAO,UAAA,EAAA,EAAgE;IACrE,IAAA,UAAA;;IACA,IAAIE,IAAI,CAAR,UAAA,EAAqB;MACnBC,UAAU,GAAGC,QAAQ,CAAA,MAAA,EAASF,IAAI,CAAlCC,UAAqB,CAArBA;IADF,CAAA,MAEO;MACLA,UAAU,GAAGE,MAAM,CAAEC,EAAD,CAAA,KAACA,IAAoBJ,IAAI,CAA7CC,SAAmB,CAAnBA;IACD;;IACD,IAAII,UAAU,CAAd,EAAc,CAAd,EAAoB;MAClBD,EAAE,CAAFA,KAAAA,GAAWA,EAAE,CAAFA,KAAAA,IAAYJ,IAAI,CAA3BI,SAAAA;MACAA,EAAE,CAAFA,UAAAA,GAAAA,UAAAA;MACA,OAAA,EAAA;IACD;;IACD,OAAO;MACLE,OAAO,EAAE,OAAA,EAAA,KAAA,UAAA,GAA2BF,EAA3B,EAAA,GADJ,EAAA;MAELH,UAAU,EAFL,UAAA;MAGL5C,KAAK,EAAI+C,EAAF,CAAA,KAAEA,IAA0CJ,IAAI,CAACO;IAHnD,CAAP;EAZF,CAAA;AAkBD;;AAEM,SAAA,SAAA,CAAA,MAAA,EAAA,MAAA,EAAuE;EAC5E,IAAA,MAAA,EAAY;IACV,KAAK,IAAL,CAAA,IAAA,MAAA,EAAwB;MACtB,IAAIJ,MAAM,CAANA,cAAAA,CAAJ,CAAIA,CAAJ,EAA8B;QAC5B,IAAMlC,KAAK,GAAGkC,MAAM,CAApB,CAAoB,CAApB;;QACA,IAAI,OAAA,KAAA,KAAA,QAAA,IAA6B,OAAOK,MAAM,CAAb,CAAa,CAAb,KAAjC,QAAA,EAAgE;UAC9DA,MAAM,CAANA,CAAM,CAANA,GAAAA,QAAAA,CAAAA,EAAAA,EACKA,MAAM,CADXA,CACW,CADXA,EAAAA,KAAAA,CAAAA;QADF,CAAA,MAKO;UACLA,MAAM,CAANA,CAAM,CAANA,GAAAA,KAAAA;QACD;MACF;IACF;EACF;;EACD,OAAA,MAAA;AACD;;ACjTD,IAAMC,UAAqB,GAAG,SAAxBA,QAAwB,CAAA,IAAA,EAAA,KAAA,EAAA,MAAA,EAAA,MAAA,EAAA,OAAA,EAAA,IAAA,EAAgD;EAC5E,IACET,IAAI,CAAJA,QAAAA,KACC,CAACG,MAAM,CAANA,cAAAA,CAAsBH,IAAI,CAA3B,KAACG,CAAD,IACCO,YAAY,CAAA,KAAA,EAAQ1C,IAAI,IAAIgC,IAAI,CAHpC,IAGgB,CAFdA,CADF,EAIE;IACA7C,MAAM,CAANA,IAAAA,CAAYwD,MAAM,CAACC,OAAO,CAAPA,QAAAA,CAAD,QAAA,EAA4BZ,IAAI,CAAlD7C,SAAkB,CAAlBA;EACD;AAPH,CAAA;ACAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AACA,IAAM0D,UAAuB,GAAG,SAA1BA,UAA0B,CAAA,IAAA,EAAA,KAAA,EAAA,MAAA,EAAA,MAAA,EAAA,OAAA,EAA0C;EACxE,IAAI,QAAA,IAAA,CAAA,KAAA,KAAuB5C,KAAK,KAAhC,EAAA,EAAyC;IACvCd,MAAM,CAANA,IAAAA,CAAYwD,MAAM,CAACC,OAAO,CAAPA,QAAAA,CAAD,UAAA,EAA8BZ,IAAI,CAApD7C,SAAkB,CAAlBA;EACD;AAHH,CAAA,C,CCdA;;;AACA,IAAA,MAAA;;AAEA,IAAA,WAAA,GAAe,SAAf,WAAe,GAAM;EACnB,IAAA,MAAA,EAAY;IACV,OAAA,MAAA;EACD;;EAED,IAAM2D,IAAI,GAAV,cAAA;;EACA,IAAMC,CAAC,GAAG,SAAJA,CAAI,CAAA,OAAA,EAAO;IAAA,OACfH,OAAO,IAAIA,OAAO,CAAlBA,iBAAAA,GAAAA,qBAAAA,IAAAA,GAAAA,QAAAA,GAAAA,IAAAA,GAAAA,aAAAA,GADe,EAAA;EAAjB,CAAA;;EAKA,IAAMI,EAAE,GAAR,gGAAA;EAGA,IAAMC,KAAK,GAAX,kBAAA;EACA,IAAMC,EAAE,GAAG,CAERD,eAFQ,KAERA,GAFQ,UAERA,GAFQ,KAERA,GAFQ,kFAERA,GAFQ,KAERA,GAFQ,UAERA,GAFQ,EAERA,GACuBA,IADvBA,GAFQ,KAERA,GAEAA,iHAFAA,GAFQ,KAERA,GAFQ,WAERA,GAFQ,EAERA,GAFQ,OAERA,GAFQ,KAERA,GAFQ,6GAERA,GAFQ,KAERA,GAFQ,cAERA,GAFQ,KAERA,GAFQ,SAERA,GAFQ,EAERA,GAG6CA,OAH7CA,GAFQ,KAERA,GAIAA,2FAJAA,GAFQ,KAERA,GAFQ,cAERA,GAFQ,KAERA,GAFQ,SAERA,GAFQ,EAERA,GAFQ,OAERA,GAFQ,KAERA,GAKAA,2FALAA,GAFQ,KAERA,GAKoBA,cALpBA,GAFQ,KAERA,GAKmCD,SALnCC,GAFQ,EAERA,GAK6CA,OAL7CA,GAFQ,KAERA,GAFQ,2FAERA,GAFQ,KAERA,GAFQ,cAERA,GAFQ,KAERA,GAFQ,SAERA,GAFQ,EAERA,GAM6CA,OAN7CA,GAFQ,KAERA,GAOQA,mGAPRA,GAFQ,KAERA,GAFQ,SAERA,GAFQ,EAERA,GAFQ,OAERA,GAFQ,KAERA,GAFQ,oLAAA,EAAA,OAAA,CAAA,cAAA,EAAA,EAAA,EAAA,OAAA,CAAA,KAAA,EAAA,EAAA,EAfQ,IAeR,EAAX,CAfmB,CAAA;;EAgCnB,IAAME,QAAQ,GAAG,IAAA,MAAA,CAAA,SAAA,EAAA,GAAA,SAAA,GAAA,EAAA,GAAjB,IAAiB,CAAjB;EACA,IAAMC,OAAO,GAAG,IAAA,MAAA,CAAA,MAAA,EAAA,GAAhB,GAAgB,CAAhB;EACA,IAAMC,OAAO,GAAG,IAAA,MAAA,CAAA,MAAA,EAAA,GAAhB,GAAgB,CAAhB;;EAEA,IAAMC,EAAE,GAAG,SAALA,EAAK,CAAA,OAAA,EAAO;IAAA,OAChBV,OAAO,IAAIA,OAAO,CAAlBA,KAAAA,GAAAA,QAAAA,GAEI,IAAA,MAAA,CAAA,QACQG,CAAC,CADT,OACS,CADT,GAAA,EAAA,GAC0BA,CAAC,CAD3B,OAC2B,CAD3B,GAAA,OAAA,GAC4CA,CAAC,CAD7C,OAC6C,CAD7C,GAAA,EAAA,GAC8DA,CAAC,CAD/D,OAC+D,CAD/D,GAAA,GAAA,EAHY,GAGZ,CAHY;EAAlB,CAAA;;EAUAO,EAAE,CAAFA,EAAAA,GAAQ,UAAA,OAAA,EAAA;IAAA,OACNV,OAAO,IAAIA,OAAO,CAAlBA,KAAAA,GAAAA,OAAAA,GAEI,IAAA,MAAA,CAAcG,KAAAA,CAAC,CAAf,OAAe,CAADA,GAAd,EAAcA,GAAkBA,CAAC,CAAjC,OAAiC,CAAjC,EAHE,GAGF,CAHE;EAARO,CAAAA;;EAIAA,EAAE,CAAFA,EAAAA,GAAQ,UAAA,OAAA,EAAA;IAAA,OACNV,OAAO,IAAIA,OAAO,CAAlBA,KAAAA,GAAAA,OAAAA,GAEI,IAAA,MAAA,CAAcG,KAAAA,CAAC,CAAf,OAAe,CAADA,GAAd,EAAcA,GAAkBA,CAAC,CAAjC,OAAiC,CAAjC,EAHE,GAGF,CAHE;EAARO,CAAAA;;EAKA,IAAMC,QAAQ,GAAd,oBAAA;EACA,IAAMC,IAAI,GAAV,sBAAA;EACA,IAAMC,IAAI,GAAGH,EAAE,CAAFA,EAAAA,GAAb,MAAA;EACA,IAAMI,IAAI,GAAGJ,EAAE,CAAFA,EAAAA,GAAb,MAAA;EACA,IAAMK,IAAI,GAAV,+DAAA;EACA,IAAMC,MAAM,GAAZ,gEAAA;EAEA,IAAMC,GAAG,GAAT,qCAAA;EACA,IAAMC,IAAI,GAAV,gBAAA;EACA,IAAM/B,IAAI,GAAV,oBAAA;EACA,IAAMgC,KAAK,GAASR,QAAT,QAASA,GAAT,UAASA,GAAT,IAASA,GAAT,eAASA,GAAT,IAASA,GAA+CG,GAA/CH,GAAT,IAASA,GAAuDI,GAAvDJ,GAAT,IAASA,GAAT,MAASA,GAAT,GAASA,GAA8EO,GAA9EP,GAAT,IAASA,GAApB,IAAA;EACAS,MAAM,GAAG,IAAA,MAAA,CAAA,SAAA,KAAA,GAAA,IAAA,EAATA,GAAS,CAATA;EACA,OAAA,MAAA;AAnEF,CAAA;ACCA;;;AAEA,IAAMC,SAAO,GAAG;EACd;EACAC,KAAK,EAFS,sOAAA;EAGd;EACA;EACA;EACA;EACAC,GAAG,EAAE;AAPS,CAAhB;AAUA,IAAMC,KAAK,GAAG;EACZC,OADY,EAAA,SAAA,OAAA,CAAA,KAAA,EACU;IACpB,OAAOD,KAAK,CAALA,MAAAA,CAAAA,KAAAA,KAAuBE,QAAQ,CAAA,KAAA,EAARA,EAAQ,CAARA,KAA9B,KAAA;EAFU,CAAA;EAAA,SAAA,SAAA,KAAA,CAAA,KAAA,EAIQ;IAClB,OAAOF,KAAK,CAALA,MAAAA,CAAAA,KAAAA,KAAuB,CAACA,KAAK,CAALA,OAAAA,CAA/B,KAA+BA,CAA/B;EALU,CAAA;EAOZG,KAPY,EAAA,SAAA,KAAA,CAAA,KAAA,EAOQ;IAClB,OAAOrE,KAAK,CAALA,OAAAA,CAAP,KAAOA,CAAP;EARU,CAAA;EAUZsE,MAVY,EAAA,SAAA,MAAA,CAAA,KAAA,EAUS;IACnB,IAAIvE,KAAK,YAAT,MAAA,EAA6B;MAC3B,OAAA,IAAA;IACD;;IACD,IAAI;MACF,OAAO,CAAC,CAAC,IAAA,MAAA,CAAT,KAAS,CAAT;IADF,CAAA,CAEE,OAAA,CAAA,EAAU;MACV,OAAA,KAAA;IACD;EAlBS,CAAA;EAoBZwE,IApBY,EAAA,SAAA,IAAA,CAAA,KAAA,EAoBO;IACjB,OACE,OAAOxE,KAAK,CAAZ,OAAA,KAAA,UAAA,IACA,OAAOA,KAAK,CAAZ,QAAA,KADA,UAAA,IAEA,OAAOA,KAAK,CAAZ,OAAA,KAFA,UAAA,IAGA,CAACyE,KAAK,CAACzE,KAAK,CAJd,OAISA,EAAD,CAJR;EArBU,CAAA;EA4BZ0E,MA5BY,EAAA,SAAA,MAAA,CAAA,KAAA,EA4BS;IACnB,IAAID,KAAK,CAAT,KAAS,CAAT,EAAkB;MAChB,OAAA,KAAA;IACD;;IACD,OAAO,OAAA,KAAA,KAAP,QAAA;EAhCU,CAAA;EAkCZE,MAlCY,EAAA,SAAA,MAAA,CAAA,KAAA,EAkCS;IACnB,OAAO,OAAA,KAAA,KAAA,QAAA,IAA6B,CAACR,KAAK,CAALA,KAAAA,CAArC,KAAqCA,CAArC;EAnCU,CAAA;EAqCZS,MArCY,EAAA,SAAA,MAAA,CAAA,KAAA,EAqCS;IACnB,OAAO,OAAA,KAAA,KAAP,UAAA;EAtCU,CAAA;EAwCZX,KAxCY,EAAA,SAAA,KAAA,CAAA,KAAA,EAwCQ;IAClB,OACE,OAAA,KAAA,KAAA,QAAA,IACAjE,KAAK,CAALA,MAAAA,IADA,GAAA,IAEA,CAAC,CAACA,KAAK,CAALA,KAAAA,CAAYgE,SAAO,CAHvB,KAGIhE,CAHJ;EAzCU,CAAA;EA+CZ6E,GA/CY,EAAA,SAAA,GAAA,CAAA,KAAA,EA+CM;IAChB,OACE,OAAA,KAAA,KAAA,QAAA,IACA7E,KAAK,CAALA,MAAAA,IADA,IAAA,IAEA,CAAC,CAACA,KAAK,CAALA,KAAAA,CAAY8E,WAHhB,EAGI9E,CAHJ;EAhDU,CAAA;EAsDZkE,GAtDY,EAAA,SAAA,GAAA,CAAA,KAAA,EAsDM;IAChB,OAAO,OAAA,KAAA,KAAA,QAAA,IAA6B,CAAC,CAAClE,KAAK,CAALA,KAAAA,CAAYgE,SAAO,CAAzD,GAAsChE,CAAtC;EACD;AAxDW,CAAd;;AA2DA,IAAMD,MAAiB,GAAG,SAApBA,IAAoB,CAAA,IAAA,EAAA,KAAA,EAAA,MAAA,EAAA,MAAA,EAAA,OAAA,EAA0C;EAClE,IAAIgC,IAAI,CAAJA,QAAAA,IAAiB/B,KAAK,KAA1B,SAAA,EAA0C;IACxCwC,UAAQ,CAAA,IAAA,EAAA,KAAA,EAAA,MAAA,EAAA,MAAA,EAARA,OAAQ,CAARA;IACA;EACD;;EACD,IAAMuC,MAAM,GAAG,CAAA,SAAA,EAAA,OAAA,EAAA,OAAA,EAAA,QAAA,EAAA,QAAA,EAAA,QAAA,EAAA,OAAA,EAAA,QAAA,EAAA,MAAA,EAAA,KAAA,EAAf,KAAe,CAAf;EAaA,IAAMC,QAAQ,GAAGjD,IAAI,CAArB,IAAA;;EACA,IAAIgD,MAAM,CAANA,OAAAA,CAAAA,QAAAA,IAA2B,CAA/B,CAAA,EAAmC;IACjC,IAAI,CAACZ,KAAK,CAALA,QAAK,CAALA,CAAL,KAAKA,CAAL,EAA6B;MAC3BjF,MAAM,CAANA,IAAAA,CACEwD,MAAM,CAACC,OAAO,CAAPA,QAAAA,CAAAA,KAAAA,CAAD,QAACA,CAAD,EAAmCZ,IAAI,CAAvC,SAAA,EAAmDA,IAAI,CAD/D7C,IACQ,CADRA;IAF+B,CAAA,CAAA;;EAAnC,CAAA,MAOO,IAAI8F,QAAQ,IAAI,OAAA,KAAA,KAAiBjD,IAAI,CAArC,IAAA,EAA4C;IACjD7C,MAAM,CAANA,IAAAA,CACEwD,MAAM,CAACC,OAAO,CAAPA,QAAAA,CAAAA,KAAAA,CAAD,QAACA,CAAD,EAAmCZ,IAAI,CAAvC,SAAA,EAAmDA,IAAI,CAD/D7C,IACQ,CADRA;EAGD;AA9BH,CAAA;;ACxEA,IAAM+F,KAAkB,GAAG,SAArBA,KAAqB,CAAA,IAAA,EAAA,KAAA,EAAA,MAAA,EAAA,MAAA,EAAA,OAAA,EAA0C;EACnE,IAAMzF,GAAG,GAAG,OAAOuC,IAAI,CAAX,GAAA,KAAZ,QAAA;EACA,IAAMmD,GAAG,GAAG,OAAOnD,IAAI,CAAX,GAAA,KAAZ,QAAA;EACA,IAAMoD,GAAG,GAAG,OAAOpD,IAAI,CAAX,GAAA,KAHuD,QAGnE,CAHmE,CAAA;;EAKnE,IAAMqD,QAAQ,GAAd,iCAAA;EACA,IAAIC,GAAG,GAAP,KAAA;EACA,IAAIC,GAAG,GAAP,IAAA;EACA,IAAMC,GAAG,GAAG,OAAA,KAAA,KAAZ,QAAA;EACA,IAAM7F,GAAG,GAAG,OAAA,KAAA,KAAZ,QAAA;EACA,IAAMY,GAAG,GAAGL,KAAK,CAALA,OAAAA,CAAZ,KAAYA,CAAZ;;EACA,IAAA,GAAA,EAAS;IACPqF,GAAG,GAAHA,QAAAA;EADF,CAAA,MAEO,IAAA,GAAA,EAAS;IACdA,GAAG,GAAHA,QAAAA;EADK,CAAA,MAEA,IAAA,GAAA,EAAS;IACdA,GAAG,GAAHA,OAAAA;EAhBiE,CAAA,CAAA;EAmBnE;EACA;;;EACA,IAAI,CAAJ,GAAA,EAAU;IACR,OAAA,KAAA;EACD;;EACD,IAAA,GAAA,EAAS;IACPD,GAAG,GAAGrF,KAAK,CAAXqF,MAAAA;EACD;;EACD,IAAA,GAAA,EAAS;IACP;IACAA,GAAG,GAAGrF,KAAK,CAALA,OAAAA,CAAAA,QAAAA,EAAAA,GAAAA,EAANqF,MAAAA;EACD;;EACD,IAAA,GAAA,EAAS;IACP,IAAIA,GAAG,KAAKtD,IAAI,CAAhB,GAAA,EAAsB;MACpB7C,MAAM,CAANA,IAAAA,CAAYwD,MAAM,CAACC,OAAO,CAAPA,QAAAA,CAAAA,GAAAA,EAAD,GAAA,EAA4BZ,IAAI,CAAhC,SAAA,EAA4CA,IAAI,CAAlE7C,GAAkB,CAAlBA;IACD;EAHH,CAAA,MAIO,IAAIgG,GAAG,IAAI,CAAPA,GAAAA,IAAeG,GAAG,GAAGtD,IAAI,CAA7B,GAAA,EAAmC;IACxC7C,MAAM,CAANA,IAAAA,CAAYwD,MAAM,CAACC,OAAO,CAAPA,QAAAA,CAAAA,GAAAA,EAAD,GAAA,EAA4BZ,IAAI,CAAhC,SAAA,EAA4CA,IAAI,CAAlE7C,GAAkB,CAAlBA;EADK,CAAA,MAEA,IAAIiG,GAAG,IAAI,CAAPA,GAAAA,IAAeE,GAAG,GAAGtD,IAAI,CAA7B,GAAA,EAAmC;IACxC7C,MAAM,CAANA,IAAAA,CAAYwD,MAAM,CAACC,OAAO,CAAPA,QAAAA,CAAAA,GAAAA,EAAD,GAAA,EAA4BZ,IAAI,CAAhC,SAAA,EAA4CA,IAAI,CAAlE7C,GAAkB,CAAlBA;EADK,CAAA,MAEA,IAAIgG,GAAG,IAAHA,GAAAA,KAAeG,GAAG,GAAGtD,IAAI,CAAVsD,GAAAA,IAAkBA,GAAG,GAAGtD,IAAI,CAA/C,GAAImD,CAAJ,EAAsD;IAC3DhG,MAAM,CAANA,IAAAA,CACEwD,MAAM,CAACC,OAAO,CAAPA,QAAAA,CAAAA,GAAAA,EAAD,KAAA,EAA8BZ,IAAI,CAAlC,SAAA,EAA8CA,IAAI,CAAlD,GAAA,EAAwDA,IAAI,CADpE7C,GACQ,CADRA;EAGD;AA3CH,CAAA;;ACAA,IAAMsG,MAAI,GAAV,MAAA;;AAEA,IAAMC,YAAuB,GAAG,SAA1BA,UAA0B,CAAA,IAAA,EAAA,KAAA,EAAA,MAAA,EAAA,MAAA,EAAA,OAAA,EAA0C;EACxE1D,IAAI,CAAJA,MAAI,CAAJA,GAAa9B,KAAK,CAALA,OAAAA,CAAc8B,IAAI,CAAlB9B,MAAkB,CAAlBA,IAA4B8B,IAAI,CAAhC9B,MAAgC,CAAhCA,GAAb8B,EAAAA;;EACA,IAAIA,IAAI,CAAJA,MAAI,CAAJA,CAAAA,OAAAA,CAAAA,KAAAA,MAA8B,CAAlC,CAAA,EAAsC;IACpC7C,MAAM,CAANA,IAAAA,CACEwD,MAAM,CAACC,OAAO,CAAPA,QAAAA,CAAD,MAACA,CAAD,EAAyBZ,IAAI,CAA7B,SAAA,EAAyCA,IAAI,CAAJA,MAAI,CAAJA,CAAAA,IAAAA,CADjD7C,IACiD6C,CAAzC,CADR7C;EAGD;AANH,CAAA;;ACFA,IAAM8E,SAAoB,GAAG,SAAvBA,OAAuB,CAAA,IAAA,EAAA,KAAA,EAAA,MAAA,EAAA,MAAA,EAAA,OAAA,EAA0C;EACrE,IAAIjC,IAAI,CAAR,OAAA,EAAkB;IAChB,IAAIA,IAAI,CAAJA,OAAAA,YAAJ,MAAA,EAAoC;MAClC;MACA;MACA;MACAA,IAAI,CAAJA,OAAAA,CAAAA,SAAAA,GAAAA,CAAAA;;MACA,IAAI,CAACA,IAAI,CAAJA,OAAAA,CAAAA,IAAAA,CAAL,KAAKA,CAAL,EAA+B;QAC7B7C,MAAM,CAANA,IAAAA,CACEwD,MAAM,CACJC,OAAO,CAAPA,QAAAA,CAAAA,OAAAA,CADI,QAAA,EAEJZ,IAAI,CAFA,SAAA,EAAA,KAAA,EAIJA,IAAI,CALR7C,OACQ,CADRA;MAQD;IAdH,CAAA,MAeO,IAAI,OAAO6C,IAAI,CAAX,OAAA,KAAJ,QAAA,EAAsC;MAC3C,IAAM2D,QAAQ,GAAG,IAAA,MAAA,CAAW3D,IAAI,CAAhC,OAAiB,CAAjB;;MACA,IAAI,CAAC2D,QAAQ,CAARA,IAAAA,CAAL,KAAKA,CAAL,EAA2B;QACzBxG,MAAM,CAANA,IAAAA,CACEwD,MAAM,CACJC,OAAO,CAAPA,QAAAA,CAAAA,OAAAA,CADI,QAAA,EAEJZ,IAAI,CAFA,SAAA,EAAA,KAAA,EAIJA,IAAI,CALR7C,OACQ,CADRA;MAQD;IACF;EACF;AA9BH,CAAA;;ACIA,IAAA,KAAA,GAAe;EACbsD,QAAQ,EADK,UAAA;EAEbI,UAAU,EAFG,UAAA;EAGb7C,IAAI,EAHS,MAAA;EAIbkF,KAAK,EAJQ,KAAA;EAKb,QALa,YAAA;EAMbjB,OAAO,EAAPA;AANa,CAAf;;ACHA,IAAM2B,MAAwB,GAAG,SAA3BA,MAA2B,CAAA,IAAA,EAAA,KAAA,EAAA,QAAA,EAAA,MAAA,EAAA,OAAA,EAA4C;EAC3E,IAAMzG,MAAgB,GAAtB,EAAA;EACA,IAAM0G,QAAQ,GACZ7D,IAAI,CAAJA,QAAAA,IAAkB,CAACA,IAAI,CAAL,QAAA,IAAkBG,MAAM,CAANA,cAAAA,CAAsBH,IAAI,CADhE,KACsCG,CADtC;;EAEA,IAAA,QAAA,EAAc;IACZ,IAAIO,YAAY,CAAA,KAAA,EAAZA,QAAY,CAAZA,IAAiC,CAACV,IAAI,CAA1C,QAAA,EAAqD;MACnD,OAAOxB,QAAP,EAAA;IACD;;IACDsF,KAAK,CAALA,QAAAA,CAAAA,IAAAA,EAAAA,KAAAA,EAAAA,MAAAA,EAAAA,MAAAA,EAAAA,OAAAA,EAAAA,QAAAA;;IACA,IAAI,CAACpD,YAAY,CAAA,KAAA,EAAjB,QAAiB,CAAjB,EAAoC;MAClCoD,KAAK,CAALA,IAAAA,CAAAA,IAAAA,EAAAA,KAAAA,EAAAA,MAAAA,EAAAA,MAAAA,EAAAA,OAAAA;MACAA,KAAK,CAALA,KAAAA,CAAAA,IAAAA,EAAAA,KAAAA,EAAAA,MAAAA,EAAAA,MAAAA,EAAAA,OAAAA;MACAA,KAAK,CAALA,OAAAA,CAAAA,IAAAA,EAAAA,KAAAA,EAAAA,MAAAA,EAAAA,MAAAA,EAAAA,OAAAA;;MACA,IAAI9D,IAAI,CAAJA,UAAAA,KAAJ,IAAA,EAA8B;QAC5B8D,KAAK,CAALA,UAAAA,CAAAA,IAAAA,EAAAA,KAAAA,EAAAA,MAAAA,EAAAA,MAAAA,EAAAA,OAAAA;MACD;IACF;EACF;;EACDtF,QAAQ,CAARA,MAAQ,CAARA;AAlBF,CAAA;;ACAA,IAAMqE,MAAwB,GAAG,SAA3BA,MAA2B,CAAA,IAAA,EAAA,KAAA,EAAA,QAAA,EAAA,MAAA,EAAA,OAAA,EAA4C;EAC3E,IAAM1F,MAAgB,GAAtB,EAAA;EACA,IAAM0G,QAAQ,GACZ7D,IAAI,CAAJA,QAAAA,IAAkB,CAACA,IAAI,CAAL,QAAA,IAAkBG,MAAM,CAANA,cAAAA,CAAsBH,IAAI,CADhE,KACsCG,CADtC;;EAEA,IAAA,QAAA,EAAc;IACZ,IAAIO,YAAY,CAAZA,KAAY,CAAZA,IAAuB,CAACV,IAAI,CAAhC,QAAA,EAA2C;MACzC,OAAOxB,QAAP,EAAA;IACD;;IACDsF,KAAK,CAALA,QAAAA,CAAAA,IAAAA,EAAAA,KAAAA,EAAAA,MAAAA,EAAAA,MAAAA,EAAAA,OAAAA;;IACA,IAAI7F,KAAK,KAAT,SAAA,EAAyB;MACvB6F,KAAK,CAALA,IAAAA,CAAAA,IAAAA,EAAAA,KAAAA,EAAAA,MAAAA,EAAAA,MAAAA,EAAAA,OAAAA;IACD;EACF;;EACDtF,QAAQ,CAARA,MAAQ,CAARA;AAbF,CAAA;;ACAA,IAAMmE,MAAwB,GAAG,SAA3BA,MAA2B,CAAA,IAAA,EAAA,KAAA,EAAA,QAAA,EAAA,MAAA,EAAA,OAAA,EAA4C;EAC3E,IAAMxF,MAAgB,GAAtB,EAAA;EACA,IAAM0G,QAAQ,GACZ7D,IAAI,CAAJA,QAAAA,IAAkB,CAACA,IAAI,CAAL,QAAA,IAAkBG,MAAM,CAANA,cAAAA,CAAsBH,IAAI,CADhE,KACsCG,CADtC;;EAEA,IAAA,QAAA,EAAc;IACZ,IAAIlC,KAAK,KAAT,EAAA,EAAkB;MAChBA,KAAK,GAALA,SAAAA;IACD;;IACD,IAAIyC,YAAY,CAAZA,KAAY,CAAZA,IAAuB,CAACV,IAAI,CAAhC,QAAA,EAA2C;MACzC,OAAOxB,QAAP,EAAA;IACD;;IACDsF,KAAK,CAALA,QAAAA,CAAAA,IAAAA,EAAAA,KAAAA,EAAAA,MAAAA,EAAAA,MAAAA,EAAAA,OAAAA;;IACA,IAAI7F,KAAK,KAAT,SAAA,EAAyB;MACvB6F,KAAK,CAALA,IAAAA,CAAAA,IAAAA,EAAAA,KAAAA,EAAAA,MAAAA,EAAAA,MAAAA,EAAAA,OAAAA;MACAA,KAAK,CAALA,KAAAA,CAAAA,IAAAA,EAAAA,KAAAA,EAAAA,MAAAA,EAAAA,MAAAA,EAAAA,OAAAA;IACD;EACF;;EACDtF,QAAQ,CAARA,MAAQ,CAARA;AAjBF,CAAA;;ACAA,IAAMuF,QAAyB,GAAG,SAA5BA,QAA4B,CAAA,IAAA,EAAA,KAAA,EAAA,QAAA,EAAA,MAAA,EAAA,OAAA,EAA4C;EAC5E,IAAM5G,MAAgB,GAAtB,EAAA;EACA,IAAM0G,QAAQ,GACZ7D,IAAI,CAAJA,QAAAA,IAAkB,CAACA,IAAI,CAAL,QAAA,IAAkBG,MAAM,CAANA,cAAAA,CAAsBH,IAAI,CADhE,KACsCG,CADtC;;EAEA,IAAA,QAAA,EAAc;IACZ,IAAIO,YAAY,CAAZA,KAAY,CAAZA,IAAuB,CAACV,IAAI,CAAhC,QAAA,EAA2C;MACzC,OAAOxB,QAAP,EAAA;IACD;;IACDsF,KAAK,CAALA,QAAAA,CAAAA,IAAAA,EAAAA,KAAAA,EAAAA,MAAAA,EAAAA,MAAAA,EAAAA,OAAAA;;IACA,IAAI7F,KAAK,KAAT,SAAA,EAAyB;MACvB6F,KAAK,CAALA,IAAAA,CAAAA,IAAAA,EAAAA,KAAAA,EAAAA,MAAAA,EAAAA,MAAAA,EAAAA,OAAAA;IACD;EACF;;EACDtF,QAAQ,CAARA,MAAQ,CAARA;AAbF,CAAA;;ACAA,IAAMgE,MAAwB,GAAG,SAA3BA,MAA2B,CAAA,IAAA,EAAA,KAAA,EAAA,QAAA,EAAA,MAAA,EAAA,OAAA,EAA4C;EAC3E,IAAMrF,MAAgB,GAAtB,EAAA;EACA,IAAM0G,QAAQ,GACZ7D,IAAI,CAAJA,QAAAA,IAAkB,CAACA,IAAI,CAAL,QAAA,IAAkBG,MAAM,CAANA,cAAAA,CAAsBH,IAAI,CADhE,KACsCG,CADtC;;EAEA,IAAA,QAAA,EAAc;IACZ,IAAIO,YAAY,CAAZA,KAAY,CAAZA,IAAuB,CAACV,IAAI,CAAhC,QAAA,EAA2C;MACzC,OAAOxB,QAAP,EAAA;IACD;;IACDsF,KAAK,CAALA,QAAAA,CAAAA,IAAAA,EAAAA,KAAAA,EAAAA,MAAAA,EAAAA,MAAAA,EAAAA,OAAAA;;IACA,IAAI,CAACpD,YAAY,CAAjB,KAAiB,CAAjB,EAA0B;MACxBoD,KAAK,CAALA,IAAAA,CAAAA,IAAAA,EAAAA,KAAAA,EAAAA,MAAAA,EAAAA,MAAAA,EAAAA,OAAAA;IACD;EACF;;EACDtF,QAAQ,CAARA,MAAQ,CAARA;AAbF,CAAA;;ACAA,IAAM6D,OAAyB,GAAG,SAA5BA,OAA4B,CAAA,IAAA,EAAA,KAAA,EAAA,QAAA,EAAA,MAAA,EAAA,OAAA,EAA4C;EAC5E,IAAMlF,MAAgB,GAAtB,EAAA;EACA,IAAM0G,QAAQ,GACZ7D,IAAI,CAAJA,QAAAA,IAAkB,CAACA,IAAI,CAAL,QAAA,IAAkBG,MAAM,CAANA,cAAAA,CAAsBH,IAAI,CADhE,KACsCG,CADtC;;EAEA,IAAA,QAAA,EAAc;IACZ,IAAIO,YAAY,CAAZA,KAAY,CAAZA,IAAuB,CAACV,IAAI,CAAhC,QAAA,EAA2C;MACzC,OAAOxB,QAAP,EAAA;IACD;;IACDsF,KAAK,CAALA,QAAAA,CAAAA,IAAAA,EAAAA,KAAAA,EAAAA,MAAAA,EAAAA,MAAAA,EAAAA,OAAAA;;IACA,IAAI7F,KAAK,KAAT,SAAA,EAAyB;MACvB6F,KAAK,CAALA,IAAAA,CAAAA,IAAAA,EAAAA,KAAAA,EAAAA,MAAAA,EAAAA,MAAAA,EAAAA,OAAAA;MACAA,KAAK,CAALA,KAAAA,CAAAA,IAAAA,EAAAA,KAAAA,EAAAA,MAAAA,EAAAA,MAAAA,EAAAA,OAAAA;IACD;EACF;;EACDtF,QAAQ,CAARA,MAAQ,CAARA;AAdF,CAAA;;ACAA,IAAMwF,OAAyB,GAAG,SAA5BA,OAA4B,CAAA,IAAA,EAAA,KAAA,EAAA,QAAA,EAAA,MAAA,EAAA,OAAA,EAA4C;EAC5E,IAAM7G,MAAgB,GAAtB,EAAA;EACA,IAAM0G,QAAQ,GACZ7D,IAAI,CAAJA,QAAAA,IAAkB,CAACA,IAAI,CAAL,QAAA,IAAkBG,MAAM,CAANA,cAAAA,CAAsBH,IAAI,CADhE,KACsCG,CADtC;;EAEA,IAAA,QAAA,EAAc;IACZ,IAAIO,YAAY,CAAZA,KAAY,CAAZA,IAAuB,CAACV,IAAI,CAAhC,QAAA,EAA2C;MACzC,OAAOxB,QAAP,EAAA;IACD;;IACDsF,KAAK,CAALA,QAAAA,CAAAA,IAAAA,EAAAA,KAAAA,EAAAA,MAAAA,EAAAA,MAAAA,EAAAA,OAAAA;;IACA,IAAI7F,KAAK,KAAT,SAAA,EAAyB;MACvB6F,KAAK,CAALA,IAAAA,CAAAA,IAAAA,EAAAA,KAAAA,EAAAA,MAAAA,EAAAA,MAAAA,EAAAA,OAAAA;MACAA,KAAK,CAALA,KAAAA,CAAAA,IAAAA,EAAAA,KAAAA,EAAAA,MAAAA,EAAAA,MAAAA,EAAAA,OAAAA;IACD;EACF;;EACDtF,QAAQ,CAARA,MAAQ,CAARA;AAdF,CAAA;;ACDA,IAAM+D,KAAuB,GAAG,SAA1BA,KAA0B,CAAA,IAAA,EAAA,KAAA,EAAA,QAAA,EAAA,MAAA,EAAA,OAAA,EAA4C;EAC1E,IAAMpF,MAAgB,GAAtB,EAAA;EACA,IAAM0G,QAAQ,GACZ7D,IAAI,CAAJA,QAAAA,IAAkB,CAACA,IAAI,CAAL,QAAA,IAAkBG,MAAM,CAANA,cAAAA,CAAsBH,IAAI,CADhE,KACsCG,CADtC;;EAEA,IAAA,QAAA,EAAc;IACZ,IAAI,CAAClC,KAAK,KAALA,SAAAA,IAAuBA,KAAK,KAA7B,IAAA,KAA2C,CAAC+B,IAAI,CAApD,QAAA,EAA+D;MAC7D,OAAOxB,QAAP,EAAA;IACD;;IACDsF,KAAK,CAALA,QAAAA,CAAAA,IAAAA,EAAAA,KAAAA,EAAAA,MAAAA,EAAAA,MAAAA,EAAAA,OAAAA,EAAAA,OAAAA;;IACA,IAAI7F,KAAK,KAALA,SAAAA,IAAuBA,KAAK,KAAhC,IAAA,EAA2C;MACzC6F,KAAK,CAALA,IAAAA,CAAAA,IAAAA,EAAAA,KAAAA,EAAAA,MAAAA,EAAAA,MAAAA,EAAAA,OAAAA;MACAA,KAAK,CAALA,KAAAA,CAAAA,IAAAA,EAAAA,KAAAA,EAAAA,MAAAA,EAAAA,MAAAA,EAAAA,OAAAA;IACD;EACF;;EACDtF,QAAQ,CAARA,MAAQ,CAARA;AAdF,CAAA;;ACCA,IAAMoE,MAAwB,GAAG,SAA3BA,MAA2B,CAAA,IAAA,EAAA,KAAA,EAAA,QAAA,EAAA,MAAA,EAAA,OAAA,EAA4C;EAC3E,IAAMzF,MAAgB,GAAtB,EAAA;EACA,IAAM0G,QAAQ,GACZ7D,IAAI,CAAJA,QAAAA,IAAkB,CAACA,IAAI,CAAL,QAAA,IAAkBG,MAAM,CAANA,cAAAA,CAAsBH,IAAI,CADhE,KACsCG,CADtC;;EAEA,IAAA,QAAA,EAAc;IACZ,IAAIO,YAAY,CAAZA,KAAY,CAAZA,IAAuB,CAACV,IAAI,CAAhC,QAAA,EAA2C;MACzC,OAAOxB,QAAP,EAAA;IACD;;IACDsF,KAAK,CAALA,QAAAA,CAAAA,IAAAA,EAAAA,KAAAA,EAAAA,MAAAA,EAAAA,MAAAA,EAAAA,OAAAA;;IACA,IAAI7F,KAAK,KAAT,SAAA,EAAyB;MACvB6F,KAAK,CAALA,IAAAA,CAAAA,IAAAA,EAAAA,KAAAA,EAAAA,MAAAA,EAAAA,MAAAA,EAAAA,OAAAA;IACD;EACF;;EACDtF,QAAQ,CAARA,MAAQ,CAARA;AAbF,CAAA;;ACAA,IAAMiF,IAAI,GAAV,MAAA;;AAEA,IAAMC,UAA4B,GAAG,SAA/BA,UAA+B,CAAA,IAAA,EAAA,KAAA,EAAA,QAAA,EAAA,MAAA,EAAA,OAAA,EAMhC;EACH,IAAMvG,MAAgB,GAAtB,EAAA;EACA,IAAM0G,QAAQ,GACZ7D,IAAI,CAAJA,QAAAA,IAAkB,CAACA,IAAI,CAAL,QAAA,IAAkBG,MAAM,CAANA,cAAAA,CAAsBH,IAAI,CADhE,KACsCG,CADtC;;EAEA,IAAA,QAAA,EAAc;IACZ,IAAIO,YAAY,CAAZA,KAAY,CAAZA,IAAuB,CAACV,IAAI,CAAhC,QAAA,EAA2C;MACzC,OAAOxB,QAAP,EAAA;IACD;;IACDsF,KAAK,CAALA,QAAAA,CAAAA,IAAAA,EAAAA,KAAAA,EAAAA,MAAAA,EAAAA,MAAAA,EAAAA,OAAAA;;IACA,IAAI7F,KAAK,KAAT,SAAA,EAAyB;MACvB6F,KAAK,CAALA,IAAK,CAALA,CAAAA,IAAAA,EAAAA,KAAAA,EAAAA,MAAAA,EAAAA,MAAAA,EAAAA,OAAAA;IACD;EACF;;EACDtF,QAAQ,CAARA,MAAQ,CAARA;AAnBF,CAAA;;ACFA,IAAMyD,OAAyB,GAAG,SAA5BA,OAA4B,CAAA,IAAA,EAAA,KAAA,EAAA,QAAA,EAAA,MAAA,EAAA,OAAA,EAA4C;EAC5E,IAAM9E,MAAgB,GAAtB,EAAA;EACA,IAAM0G,QAAQ,GACZ7D,IAAI,CAAJA,QAAAA,IAAkB,CAACA,IAAI,CAAL,QAAA,IAAkBG,MAAM,CAANA,cAAAA,CAAsBH,IAAI,CADhE,KACsCG,CADtC;;EAEA,IAAA,QAAA,EAAc;IACZ,IAAIO,YAAY,CAAA,KAAA,EAAZA,QAAY,CAAZA,IAAiC,CAACV,IAAI,CAA1C,QAAA,EAAqD;MACnD,OAAOxB,QAAP,EAAA;IACD;;IACDsF,KAAK,CAALA,QAAAA,CAAAA,IAAAA,EAAAA,KAAAA,EAAAA,MAAAA,EAAAA,MAAAA,EAAAA,OAAAA;;IACA,IAAI,CAACpD,YAAY,CAAA,KAAA,EAAjB,QAAiB,CAAjB,EAAoC;MAClCoD,KAAK,CAALA,OAAAA,CAAAA,IAAAA,EAAAA,KAAAA,EAAAA,MAAAA,EAAAA,MAAAA,EAAAA,OAAAA;IACD;EACF;;EACDtF,QAAQ,CAARA,MAAQ,CAARA;AAbF,CAAA;;ACAA,IAAMiE,IAAsB,GAAG,SAAzBA,IAAyB,CAAA,IAAA,EAAA,KAAA,EAAA,QAAA,EAAA,MAAA,EAAA,OAAA,EAA4C;EACzE;EACA,IAAMtF,MAAgB,GAAtB,EAAA;EACA,IAAM0G,QAAQ,GACZ7D,IAAI,CAAJA,QAAAA,IAAkB,CAACA,IAAI,CAAL,QAAA,IAAkBG,MAAM,CAANA,cAAAA,CAAsBH,IAAI,CAJS,KAInCG,CADtC,CAHyE,CAAA;;EAMzE,IAAA,QAAA,EAAc;IACZ,IAAIO,YAAY,CAAA,KAAA,EAAZA,MAAY,CAAZA,IAA+B,CAACV,IAAI,CAAxC,QAAA,EAAmD;MACjD,OAAOxB,QAAP,EAAA;IACD;;IACDsF,KAAK,CAALA,QAAAA,CAAAA,IAAAA,EAAAA,KAAAA,EAAAA,MAAAA,EAAAA,MAAAA,EAAAA,OAAAA;;IACA,IAAI,CAACpD,YAAY,CAAA,KAAA,EAAjB,MAAiB,CAAjB,EAAkC;MAChC,IAAA,UAAA;;MAEA,IAAIzC,KAAK,YAAT,IAAA,EAA2B;QACzBgG,UAAU,GAAVA,KAAAA;MADF,CAAA,MAEO;QACLA,UAAU,GAAG,IAAA,IAAA,CAAbA,KAAa,CAAbA;MACD;;MAEDH,KAAK,CAALA,IAAAA,CAAAA,IAAAA,EAAAA,UAAAA,EAAAA,MAAAA,EAAAA,MAAAA,EAAAA,OAAAA;;MACA,IAAA,UAAA,EAAgB;QACdA,KAAK,CAALA,KAAAA,CAAAA,IAAAA,EAAkBG,UAAU,CAA5BH,OAAkBG,EAAlBH,EAAAA,MAAAA,EAAAA,MAAAA,EAAAA,OAAAA;MACD;IACF;EACF;;EACDtF,QAAQ,CAARA,MAAQ,CAARA;AA1BF,CAAA;;ACDA,IAAMiC,QAA0B,GAAG,SAA7BA,QAA6B,CAAA,IAAA,EAAA,KAAA,EAAA,QAAA,EAAA,MAAA,EAAA,OAAA,EAA4C;EAC7E,IAAMtD,MAAgB,GAAtB,EAAA;EACA,IAAMa,IAAI,GAAGE,KAAK,CAALA,OAAAA,CAAAA,KAAAA,IAAAA,OAAAA,GAAiC,OAA9C,KAAA;EACA4F,KAAK,CAALA,QAAAA,CAAAA,IAAAA,EAAAA,KAAAA,EAAAA,MAAAA,EAAAA,MAAAA,EAAAA,OAAAA,EAAAA,IAAAA;EACAtF,QAAQ,CAARA,MAAQ,CAARA;AAJF,CAAA;;ACCA,IAAMR,IAAsB,GAAG,SAAzBA,IAAyB,CAAA,IAAA,EAAA,KAAA,EAAA,QAAA,EAAA,MAAA,EAAA,OAAA,EAA4C;EACzE,IAAMiF,QAAQ,GAAGjD,IAAI,CAArB,IAAA;EACA,IAAM7C,MAAgB,GAAtB,EAAA;EACA,IAAM0G,QAAQ,GACZ7D,IAAI,CAAJA,QAAAA,IAAkB,CAACA,IAAI,CAAL,QAAA,IAAkBG,MAAM,CAANA,cAAAA,CAAsBH,IAAI,CADhE,KACsCG,CADtC;;EAEA,IAAA,QAAA,EAAc;IACZ,IAAIO,YAAY,CAAA,KAAA,EAAZA,QAAY,CAAZA,IAAiC,CAACV,IAAI,CAA1C,QAAA,EAAqD;MACnD,OAAOxB,QAAP,EAAA;IACD;;IACDsF,KAAK,CAALA,QAAAA,CAAAA,IAAAA,EAAAA,KAAAA,EAAAA,MAAAA,EAAAA,MAAAA,EAAAA,OAAAA,EAAAA,QAAAA;;IACA,IAAI,CAACpD,YAAY,CAAA,KAAA,EAAjB,QAAiB,CAAjB,EAAoC;MAClCoD,KAAK,CAALA,IAAAA,CAAAA,IAAAA,EAAAA,KAAAA,EAAAA,MAAAA,EAAAA,MAAAA,EAAAA,OAAAA;IACD;EACF;;EACDtF,QAAQ,CAARA,MAAQ,CAARA;AAdF,CAAA;;ACAA,IAAM0F,GAAqB,GAAG,SAAxBA,GAAwB,CAAA,IAAA,EAAA,KAAA,EAAA,QAAA,EAAA,MAAA,EAAA,OAAA,EAA4C;EACxE,IAAM/G,MAAgB,GAAtB,EAAA;EACA,IAAM0G,QAAQ,GACZ7D,IAAI,CAAJA,QAAAA,IAAkB,CAACA,IAAI,CAAL,QAAA,IAAkBG,MAAM,CAANA,cAAAA,CAAsBH,IAAI,CADhE,KACsCG,CADtC;;EAEA,IAAA,QAAA,EAAc;IACZ,IAAIO,YAAY,CAAZA,KAAY,CAAZA,IAAuB,CAACV,IAAI,CAAhC,QAAA,EAA2C;MACzC,OAAOxB,QAAP,EAAA;IACD;;IACDsF,KAAK,CAALA,QAAAA,CAAAA,IAAAA,EAAAA,KAAAA,EAAAA,MAAAA,EAAAA,MAAAA,EAAAA,OAAAA;EACD;;EACDtF,QAAQ,CAARA,MAAQ,CAARA;AAVF,CAAA;;ACYA,IAAA,UAAA,GAAe;EACboF,MAAM,EADO,MAAA;EAEbf,MAAM,EAFO,MAAA;EAGbF,MAAM,EAHO,MAAA;EAIb,WAJa,QAAA;EAKbH,MAAM,EALO,MAAA;EAMbH,OAAO,EANM,OAAA;EAOb,SAPa,OAAA;EAQbE,KAAK,EARQ,KAAA;EASbK,MAAM,EATO,MAAA;EAUb,QAVa,UAAA;EAWbX,OAAO,EAXM,OAAA;EAYbQ,IAAI,EAZS,IAAA;EAabK,GAAG,EAbU,IAAA;EAcbX,GAAG,EAdU,IAAA;EAebD,KAAK,EAfQ,IAAA;EAgBbzB,QAAQ,EAhBK,QAAA;EAiBbyD,GAAG,EAAHA;AAjBa,CAAf;;ACdO,SAAA,WAAA,GAAiD;EACtD,OAAO;IACL,WADK,8BAAA;IAELzD,QAAQ,EAFH,gBAAA;IAGL,QAHK,sBAAA;IAILI,UAAU,EAJL,oBAAA;IAKL4B,IAAI,EAAE;MACJ9B,MAAM,EADF,qCAAA;MAEJwD,KAAK,EAFD,6CAAA;MAGJC,OAAO,EAAE;IAHL,CALD;IAULhC,KAAK,EAAE;MACLwB,MAAM,EADD,gBAAA;MAELf,MAAM,EAFD,2BAAA;MAGLN,KAAK,EAHA,iBAAA;MAILK,MAAM,EAJD,iBAAA;MAKLD,MAAM,EALD,gBAAA;MAMLF,IAAI,EANC,gBAAA;MAOL,WAPK,gBAAA;MAQLJ,OAAO,EARF,iBAAA;MASL,SATK,gBAAA;MAULG,MAAM,EAVD,sBAAA;MAWLN,KAAK,EAXA,sBAAA;MAYLY,GAAG,EAZE,sBAAA;MAaLX,GAAG,EAAE;IAbA,CAVF;IAyBLyB,MAAM,EAAE;MACNnG,GAAG,EADG,kCAAA;MAEN0F,GAAG,EAFG,mCAAA;MAGNC,GAAG,EAHG,wCAAA;MAINF,KAAK,EAAE;IAJD,CAzBH;IA+BLP,MAAM,EAAE;MACNlF,GAAG,EADG,kBAAA;MAEN0F,GAAG,EAFG,2BAAA;MAGNC,GAAG,EAHG,8BAAA;MAINF,KAAK,EAAE;IAJD,CA/BH;IAqCLX,KAAK,EAAE;MACL9E,GAAG,EADE,iCAAA;MAEL0F,GAAG,EAFE,qCAAA;MAGLC,GAAG,EAHE,wCAAA;MAILF,KAAK,EAAE;IAJF,CArCF;IA2CLjB,OAAO,EAAE;MACPoC,QAAQ,EAAE;IADH,CA3CJ;IA8CLC,KA9CK,EA8CG,SAAA,KAAA,GAAA;MACN,IAAMC,MAAM,GAAGxG,IAAI,CAAJA,KAAAA,CAAWA,IAAI,CAAJA,SAAAA,CAA1B,IAA0BA,CAAXA,CAAf;MACAwG,MAAM,CAANA,KAAAA,GAAe,KAAfA,KAAAA;MACA,OAAA,MAAA;IACD;EAlDI,CAAP;AAoDD;;AAEM,IAAMC,QAAQ,GAAGC,WAAjB,EAAA;AC5BP;AACA;AACA;AACA;AACA;AACA;;IACMC,MAAAA,GAAAA,aAAAA,YAAAA;EACJ;EAgBA;EAIA,SAAA,MAAA,CAAA,UAAA,EAA+B;IAH/BZ,KAAAA,KAAAA,GAAoC,IAApCA;IACAgB,KAAAA,SAAAA,GAAsCD,QAAtCC;IAGE,KAAA,MAAA,CAAA,UAAA;EACD;;;;SAEDC,M,GAAAA,SAAOjB,MAAPiB,CAAAA,KAAAA,EAAqB;IAAA,IAAA,KAAA,GAAA,IAAA;;IACnB,IAAI,CAAJ,KAAA,EAAY;MACV,MAAM,IAAA,KAAA,CAAN,yCAAM,CAAN;IACD;;IACD,IAAI,OAAA,KAAA,KAAA,QAAA,IAA6B7G,KAAK,CAALA,OAAAA,CAAjC,KAAiCA,CAAjC,EAAuD;MACrD,MAAM,IAAA,KAAA,CAAN,yBAAM,CAAN;IACD;;IACD,KAAA,KAAA,GAAA,EAAA;IAEAY,MAAM,CAANA,IAAAA,CAAAA,KAAAA,EAAAA,OAAAA,CAA2B,UAAA,IAAA,EAAQ;MACjC,IAAMkG,IAAU,GAAGlB,KAAK,CAAxB,IAAwB,CAAxB;MACA,KAAI,CAAJ,KAAA,CAAA,IAAA,IAAmB5F,KAAK,CAALA,OAAAA,CAAAA,IAAAA,IAAAA,IAAAA,GAA6B,CAAhD,IAAgD,CAAhD;IAFFY,CAAAA;;;SAMF0F,Q,GAAAA,SAASA,QAATA,CAAAA,SAAAA,EAAsC;IACpC,IAAA,SAAA,EAAc;MACZ,KAAA,SAAA,GAAiBS,SAAS,CAACR,WAAD,EAAA,EAA1B,SAA0B,CAA1B;IACD;;IACD,OAAO,KAAP,SAAA;;;EAWFZ,MAAAA,CAAAA,QAAAA,GAAAA,SAASqB,QAATrB,CAAAA,OAAAA,EAAAA,CAAAA,EAAAA,EAAAA,EAA4E;IAAA,IAAA,MAAA,GAAA,IAAA;;IAAA,IAAlDsB,CAAkD,KAAA,KAAA,CAAA,EAAA;MAAlDA,CAAkD,GAAzC,EAATA;IAAkD;;IAAA,IAArCC,EAAqC,KAAA,KAAA,CAAA,EAAA;MAArCA,EAAqC,GAA3B,SAAM,EAAN,GAAM,CAAqB,CAArCA;IAAqC;;IAC1E,IAAIjF,MAAc,GAAlB,OAAA;IACA,IAAIS,OAAuB,GAA3B,CAAA;IACA,IAAIpC,QAA0B,GAA9B,EAAA;;IACA,IAAI,OAAA,OAAA,KAAJ,UAAA,EAAmC;MACjCA,QAAQ,GAARA,OAAAA;MACAoC,OAAO,GAAPA,EAAAA;IACD;;IACD,IAAI,CAAC,KAAD,KAAA,IAAe9B,MAAM,CAANA,IAAAA,CAAY,KAAZA,KAAAA,EAAAA,MAAAA,KAAnB,CAAA,EAAyD;MACvD,IAAA,QAAA,EAAc;QACZN,QAAQ,CAAA,IAAA,EAARA,MAAQ,CAARA;MACD;;MACD,OAAO6G,OAAO,CAAPA,OAAAA,CAAP,MAAOA,CAAP;IACD;;IAED,SAAA,QAAA,CAAA,OAAA,EAAgE;MAC9D,IAAIlI,MAAuB,GAA3B,EAAA;MACA,IAAIC,MAA2B,GAA/B,EAAA;;MAEA,SAAA,GAAA,CAAA,CAAA,EAAiD;QAC/C,IAAIc,KAAK,CAALA,OAAAA,CAAJ,CAAIA,CAAJ,EAAsB;UAAA,IAAA,OAAA;;UACpBf,MAAM,GAAG,CAAA,OAAA,GAAA,MAAA,EAAA,MAAA,CAAA,KAAA,CAAA,OAAA,EAATA,CAAS,CAATA;QADF,CAAA,MAEO;UACLA,MAAM,CAANA,IAAAA,CAAAA,CAAAA;QACD;MACF;;MAED,KAAK,IAAIK,CAAC,GAAV,CAAA,EAAgBA,CAAC,GAAGY,OAAO,CAA3B,MAAA,EAAoCZ,CAApC,EAAA,EAAyC;QACvC8H,GAAG,CAAClH,OAAO,CAAXkH,CAAW,CAAR,CAAHA;MACD;;MACD,IAAI,CAACnI,MAAM,CAAX,MAAA,EAAoB;QAClBqB,QAAQ,CAAA,IAAA,EAARA,MAAQ,CAARA;MADF,CAAA,MAEO;QACLpB,MAAM,GAAGgC,kBAAkB,CAA3BhC,MAA2B,CAA3BA;QACCoB,QAAD,CAAA,MAAA,EAAA,MAAA,CAACA;MAIF;IACF;;IAED,IAAIoC,OAAO,CAAX,QAAA,EAAsB;MACpB,IAAI4D,UAAQ,GAAG,KAAf,QAAe,EAAf;;MACA,IAAIA,UAAQ,KAAZ,QAAA,EAAkC;QAChCA,UAAQ,GAAGC,WAAXD,EAAAA;MACD;;MACDS,SAAS,CAAA,UAAA,EAAWrE,OAAO,CAA3BqE,QAAS,CAATA;MACArE,OAAO,CAAPA,QAAAA,GAAAA,UAAAA;IANF,CAAA,MAOO;MACLA,OAAO,CAAPA,QAAAA,GAAmB,KAAnBA,QAAmB,EAAnBA;IACD;;IAED,IAAM2E,MAA0C,GAAhD,EAAA;IACA,IAAMC,IAAI,GAAG5E,OAAO,CAAPA,IAAAA,IAAgB9B,MAAM,CAANA,IAAAA,CAAY,KAAzC,KAA6BA,CAA7B;IACA0G,IAAI,CAAJA,OAAAA,CAAa,UAAA,CAAA,EAAK;MAChB,IAAMjH,GAAG,GAAG,MAAI,CAAJ,KAAA,CAAZ,CAAY,CAAZ;MACA,IAAIN,KAAK,GAAGkC,MAAM,CAAlB,CAAkB,CAAlB;MACA5B,GAAG,CAAHA,OAAAA,CAAY,UAAA,CAAA,EAAK;QACf,IAAIyB,IAAsB,GAA1B,CAAA;;QACA,IAAI,OAAOA,IAAI,CAAX,SAAA,KAAJ,UAAA,EAA0C;UACxC,IAAIG,MAAM,KAAV,OAAA,EAAwB;YACtBA,MAAM,GAAA,QAAA,CAAA,EAAA,EAANA,MAAM,CAANA;UACD;;UACDlC,KAAK,GAAGkC,MAAM,CAANA,CAAM,CAANA,GAAYH,IAAI,CAAJA,SAAAA,CAApB/B,KAAoB+B,CAApB/B;QACD;;QACD,IAAI,OAAA,IAAA,KAAJ,UAAA,EAAgC;UAC9B+B,IAAI,GAAG;YACLyF,SAAS,EAAEzF;UADN,CAAPA;QADF,CAAA,MAIO;UACLA,IAAI,GAAA,QAAA,CAAA,EAAA,EAAJA,IAAI,CAAJA;QAba,CAAA,CAAA;;;QAiBfA,IAAI,CAAJA,SAAAA,GAAiB,MAAI,CAAJ,mBAAA,CAAjBA,IAAiB,CAAjBA;;QACA,IAAI,CAACA,IAAI,CAAT,SAAA,EAAqB;UACnB;QACD;;QAEDA,IAAI,CAAJA,KAAAA,GAAAA,CAAAA;QACAA,IAAI,CAAJA,SAAAA,GAAiBA,IAAI,CAAJA,SAAAA,IAAjBA,CAAAA;QACAA,IAAI,CAAJA,IAAAA,GAAY,MAAI,CAAJ,OAAA,CAAZA,IAAY,CAAZA;QACAuF,MAAM,CAANA,CAAM,CAANA,GAAYA,MAAM,CAANA,CAAM,CAANA,IAAZA,EAAAA;QACAA,MAAM,CAANA,CAAM,CAANA,CAAAA,IAAAA,CAAe;UACbvF,IAAI,EADS,IAAA;UAEb/B,KAAK,EAFQ,KAAA;UAGbkC,MAAM,EAHO,MAAA;UAIb9C,KAAK,EAAEqI;QAJM,CAAfH;MA1BFhH,CAAAA;IAHFiH,CAAAA;IAqCA,IAAMG,WAAW,GAAjB,EAAA;IACA,OAAOC,QAAQ,CAAA,MAAA,EAAA,OAAA,EAGb,UAAA,IAAA,EAAA,IAAA,EAAgB;MACd,IAAM5F,IAAI,GAAG6F,IAAI,CAAjB,IAAA;MACA,IAAIC,IAAI,GACN,CAAC9F,IAAI,CAAJA,IAAAA,KAAAA,QAAAA,IAA0BA,IAAI,CAAJA,IAAAA,KAA3B,OAAA,MACC,OAAOA,IAAI,CAAX,MAAA,KAAA,QAAA,IACC,OAAOA,IAAI,CAAX,YAAA,KAHJ,QACE,CADF;MAIA8F,IAAI,GAAGA,IAAI,KAAK9F,IAAI,CAAJA,QAAAA,IAAkB,CAACA,IAAI,CAAL,QAAA,IAAkB6F,IAAI,CAAxDC,KAAW,CAAXA;MACA9F,IAAI,CAAJA,KAAAA,GAAa6F,IAAI,CAAjB7F,KAAAA;;MAEA,SAAA,YAAA,CAAA,GAAA,EAAA,MAAA,EAAqD;QACnD,OAAA,QAAA,CAAA,EAAA,EAAA,MAAA,EAAA;UAEEO,SAAS,EAAKP,IAAI,CAAT,SAAKA,GAAL,GAAKA,GAFhB,GAAA;UAGE+F,UAAU,EAAE/F,IAAI,CAAJA,UAAAA,GAAsBA,GAAAA,MAAAA,CAAAA,IAAI,CAA1BA,UAAsBA,EAAiBuD,CAAvCvD,GAAuCuD,CAAjBvD,CAAtBA,GAA8C,CAAA,GAAA;QAH5D,CAAA,CAAA;MAKD;;MAED,SAAA,EAAA,CAAA,CAAA,EAAqD;QAAA,IAAzCgG,CAAyC,KAAA,KAAA,CAAA,EAAA;UAAzCA,CAAyC,GAAJ,EAArCA;QAAyC;;QACnD,IAAIC,SAAS,GAAG/H,KAAK,CAALA,OAAAA,CAAAA,CAAAA,IAAAA,CAAAA,GAAuB,CAAvC,CAAuC,CAAvC;;QACA,IAAI,CAAC0C,OAAO,CAAR,eAAA,IAA4BqF,SAAS,CAAzC,MAAA,EAAkD;UAChDvB,MAAM,CAANA,OAAAA,CAAAA,kBAAAA,EAAAA,SAAAA;QACD;;QACD,IAAIuB,SAAS,CAATA,MAAAA,IAAoBjG,IAAI,CAAJA,OAAAA,KAAxB,SAAA,EAAoD;UAClDiG,SAAS,GAAG,GAAA,MAAA,CAAUjG,IAAI,CAA1BiG,OAAY,CAAZA;QANiD,CAAA,CAAA;;;QAUnD,IAAIC,YAAY,GAAGD,SAAS,CAATA,GAAAA,CAAcE,eAAe,CAAA,IAAA,EAAhD,MAAgD,CAA7BF,CAAnB;;QAEA,IAAIrF,OAAO,CAAPA,KAAAA,IAAiBsF,YAAY,CAAjC,MAAA,EAA0C;UACxCP,WAAW,CAAC3F,IAAI,CAAhB2F,KAAW,CAAXA,GAAAA,CAAAA;UACA,OAAOS,IAAI,CAAX,YAAW,CAAX;QACD;;QACD,IAAI,CAAJ,IAAA,EAAW;UACTA,IAAI,CAAJA,YAAI,CAAJA;QADF,CAAA,MAEO;UACL;UACA;UACA;UACA,IAAIpG,IAAI,CAAJA,QAAAA,IAAiB,CAAC6F,IAAI,CAA1B,KAAA,EAAkC;YAChC,IAAI7F,IAAI,CAAJA,OAAAA,KAAJ,SAAA,EAAgC;cAC9BkG,YAAY,GAAG,GAAA,MAAA,CACLlG,IAAI,CADC,OAAA,EAAA,GAAA,CAERmG,eAAe,CAAA,IAAA,EAFtBD,MAEsB,CAFP,CAAfA;YADF,CAAA,MAIO,IAAItF,OAAO,CAAX,KAAA,EAAmB;cACxBsF,YAAY,GAAG,CACbtF,OAAO,CAAPA,KAAAA,CAAAA,IAAAA,EAEED,MAAM,CAACC,OAAO,CAAPA,QAAAA,CAAD,QAAA,EAA4BZ,IAAI,CAH1CkG,KAGU,CAFRtF,CADa,CAAfsF;YAMD;;YACD,OAAOE,IAAI,CAAX,YAAW,CAAX;UACD;;UAED,IAAIC,YAAkC,GAAtC,EAAA;;UACA,IAAIrG,IAAI,CAAR,YAAA,EAAuB;YACrBlB,MAAM,CAANA,IAAAA,CAAY+G,IAAI,CAAhB/G,KAAAA,EAAAA,GAAAA,CAA4B,UAAA,GAAA,EAAO;cACjCuH,YAAY,CAAZA,GAAY,CAAZA,GAAoBrG,IAAI,CAAxBqG,YAAAA;YADFvH,CAAAA;UAGD;;UACDuH,YAAY,GAAA,QAAA,CAAA,EAAA,EAAA,YAAA,EAEPR,IAAI,CAAJA,IAAAA,CAFLQ,MAAY,CAAZA;UAKA,IAAMC,iBAA6C,GAAnD,EAAA;UAEAxH,MAAM,CAANA,IAAAA,CAAAA,YAAAA,EAAAA,OAAAA,CAAkC,UAAA,KAAA,EAAS;YACzC,IAAMyH,WAAW,GAAGF,YAAY,CAAhC,KAAgC,CAAhC;YACA,IAAMG,eAAe,GAAGtI,KAAK,CAALA,OAAAA,CAAAA,WAAAA,IAAAA,WAAAA,GAEpB,CAFJ,WAEI,CAFJ;YAGAoI,iBAAiB,CAAjBA,KAAiB,CAAjBA,GAA2BE,eAAe,CAAfA,GAAAA,CACzBC,YAAY,CAAZA,IAAAA,CAAAA,IAAAA,EADFH,KACEG,CADyBD,CAA3BF;UALFxH,CAAAA;UASA,IAAM4H,MAAM,GAAG,IAAA,MAAA,CAAf,iBAAe,CAAf;UACAA,MAAM,CAANA,QAAAA,CAAgB9F,OAAO,CAAvB8F,QAAAA;;UACA,IAAIb,IAAI,CAAJA,IAAAA,CAAJ,OAAA,EAAuB;YACrBA,IAAI,CAAJA,IAAAA,CAAAA,OAAAA,CAAAA,QAAAA,GAA6BjF,OAAO,CAApCiF,QAAAA;YACAA,IAAI,CAAJA,IAAAA,CAAAA,OAAAA,CAAAA,KAAAA,GAA0BjF,OAAO,CAAjCiF,KAAAA;UACD;;UACDa,MAAM,CAANA,QAAAA,CAAgBb,IAAI,CAApBa,KAAAA,EAA4Bb,IAAI,CAAJA,IAAAA,CAAAA,OAAAA,IAA5Ba,OAAAA,EAA0D,UAAA,IAAA,EAAQ;YAChE,IAAMC,WAAW,GAAjB,EAAA;;YACA,IAAIT,YAAY,IAAIA,YAAY,CAAhC,MAAA,EAAyC;cACvCS,WAAW,CAAXA,IAAAA,CAAAA,KAAAA,CAAAA,WAAAA,EAAAA,YAAAA;YACD;;YACD,IAAIC,IAAI,IAAIA,IAAI,CAAhB,MAAA,EAAyB;cACvBD,WAAW,CAAXA,IAAAA,CAAAA,KAAAA,CAAAA,WAAAA,EAAAA,IAAAA;YACD;;YACDP,IAAI,CAACO,WAAW,CAAXA,MAAAA,GAAAA,WAAAA,GAALP,IAAI,CAAJA;UARFM,CAAAA;QAUD;MACF;;MAED,IAAA,GAAA;;MACA,IAAI1G,IAAI,CAAR,cAAA,EAAyB;QACvB6G,GAAG,GAAG7G,IAAI,CAAJA,cAAAA,CAAAA,IAAAA,EAA0B6F,IAAI,CAA9B7F,KAAAA,EAAAA,EAAAA,EAA0C6F,IAAI,CAA9C7F,MAAAA,EAAN6G,OAAM7G,CAAN6G;MADF,CAAA,MAEO,IAAI7G,IAAI,CAAR,SAAA,EAAoB;QACzB,IAAI;UACF6G,GAAG,GAAG7G,IAAI,CAAJA,SAAAA,CAAAA,IAAAA,EAAqB6F,IAAI,CAAzB7F,KAAAA,EAAAA,EAAAA,EAAqC6F,IAAI,CAAzC7F,MAAAA,EAAN6G,OAAM7G,CAAN6G;QADF,CAAA,CAEE,OAAA,KAAA,EAAc;UACd3J,OAAO,CAAPA,KAAAA,IAAAA,IAAAA,GAAAA,KAAAA,CAAAA,GAAAA,OAAO,CAAPA,KAAAA,CADc,KACdA,CAAAA,CADc,CAAA;;UAGd,IAAI,CAAC0D,OAAO,CAAZ,sBAAA,EAAqC;YACnCkG,UAAU,CAAC,YAAM;cACf,MAAA,KAAA;YADQ,CAAA,EAAVA,CAAU,CAAVA;UAGD;;UACDC,EAAE,CAACzJ,KAAK,CAARyJ,OAAE,CAAFA;QACD;;QACD,IAAIF,GAAG,KAAP,IAAA,EAAkB;UAChBE,EAAE;QADJ,CAAA,MAEO,IAAIF,GAAG,KAAP,KAAA,EAAmB;UACxBE,EAAE,CACA,OAAO/G,IAAI,CAAX,OAAA,KAAA,UAAA,GACIA,IAAI,CAAJA,OAAAA,CAAaA,IAAI,CAAJA,SAAAA,IAAkBA,IAAI,CADvC,KACIA,CADJ,GAEIA,IAAI,CAAJA,OAAAA,IAAAA,CAAmBA,IAAI,CAAJA,SAAAA,IAAkBA,IAAI,CAAzCA,KAAAA,IAHN+G,QAAE,CAAFA;QADK,CAAA,MAMA,IAAIF,GAAG,YAAP,KAAA,EAA0B;UAC/BE,EAAE,CAAFA,GAAE,CAAFA;QADK,CAAA,MAEA,IAAIF,GAAG,YAAP,KAAA,EAA0B;UAC/BE,EAAE,CAACF,GAAG,CAANE,OAAE,CAAFA;QACD;MACF;;MACD,IAAIF,GAAG,IAAKA,GAAD,CAAX,IAAA,EAAwC;QACrCA,GAAD,CAAA,IAACA,CACC,YAAA;UAAA,OAAME,EAAN,EAAA;QADF,CAACF,EAEC,UAAA,CAAA,EAAC;UAAA,OAAIE,EAAE,CAAN,CAAM,CAAN;QAFH,CAACF;MAIF;IAtIU,CAAA,EAwIb,UAAA,OAAA,EAAW;MACTG,QAAQ,CAARA,OAAQ,CAARA;IAzIW,CAAA,EAAf,MAAe,CAAf;GA5FFnD;;SA2OAoD,O,GAAAA,SAAQjH,OAARiH,CAAAA,IAAAA,EAAgC;IAC9B,IAAIjH,IAAI,CAAJA,IAAAA,KAAAA,SAAAA,IAA2BA,IAAI,CAAJA,OAAAA,YAA/B,MAAA,EAA+D;MAC7DA,IAAI,CAAJA,IAAAA,GAAAA,SAAAA;IACD;;IACD,IACE,OAAOA,IAAI,CAAX,SAAA,KAAA,UAAA,IACAA,IAAI,CADJ,IAAA,IAEA,CAAC4E,UAAU,CAAVA,cAAAA,CAA0B5E,IAAI,CAHjC,IAGG4E,CAHH,EAIE;MACA,MAAM,IAAA,KAAA,CAAUjE,MAAM,CAAA,sBAAA,EAAyBX,IAAI,CAAnD,IAAsB,CAAhB,CAAN;IACD;;IACD,OAAOA,IAAI,CAAJA,IAAAA,IAAP,QAAA;;;SAGFkH,mB,GAAAA,SAAoBlH,mBAApBkH,CAAAA,IAAAA,EAA4C;IAC1C,IAAI,OAAOlH,IAAI,CAAX,SAAA,KAAJ,UAAA,EAA0C;MACxC,OAAOA,IAAI,CAAX,SAAA;IACD;;IACD,IAAMwF,IAAI,GAAG1G,MAAM,CAANA,IAAAA,CAAb,IAAaA,CAAb;IACA,IAAMqI,YAAY,GAAG3B,IAAI,CAAJA,OAAAA,CAArB,SAAqBA,CAArB;;IACA,IAAI2B,YAAY,KAAK,CAArB,CAAA,EAAyB;MACvB3B,IAAI,CAAJA,MAAAA,CAAAA,YAAAA,EAAAA,CAAAA;IACD;;IACD,IAAIA,IAAI,CAAJA,MAAAA,KAAAA,CAAAA,IAAqBA,IAAI,CAAJA,CAAI,CAAJA,KAAzB,UAAA,EAAiD;MAC/C,OAAOZ,UAAU,CAAjB,QAAA;IACD;;IACD,OAAOA,UAAU,CAAC,KAAA,OAAA,CAAXA,IAAW,CAAD,CAAVA,IAAP,SAAA;;;;CA5TEF,E;;AAAAA,MAAAA,CAEGC,QAFHD,GAEc,SAAA,QAAA,CAAA,IAAA,EAAA,SAAA,EAA2C;EAC3D,IAAI,OAAA,SAAA,KAAJ,UAAA,EAAqC;IACnC,MAAM,IAAA,KAAA,CAAN,kEAAM,CAAN;EAGD;;EACDE,UAAU,CAAVA,IAAU,CAAVA,GAAAA,SAAAA;AACD,CATGF;;AAAAA,MAAAA,CAWG1H,OAXH0H,GAWa1H,OAXb0H;AAAAA,MAAAA,CAaGF,QAbHE,GAacG,QAbdH;AAAAA,MAAAA,CAeGE,UAfHF,GAegBE,UAfhBF","sourcesContent":["/* eslint no-console:0 */\n\nimport {\n  ValidateError,\n  ValidateOption,\n  RuleValuePackage,\n  InternalRuleItem,\n  SyncErrorType,\n  RuleType,\n  Value,\n  Values,\n} from './interface';\n\nconst formatRegExp = /%[sdj%]/g;\n\ndeclare var ASYNC_VALIDATOR_NO_WARNING;\n\nexport let warning: (type: string, errors: SyncErrorType[]) => void = () => {};\n\n// don't print warning message when in production env or node runtime\nif (\n  typeof process !== 'undefined' &&\n  process.env &&\n  process.env.NODE_ENV !== 'production' &&\n  typeof window !== 'undefined' &&\n  typeof document !== 'undefined'\n) {\n  warning = (type, errors) => {\n    if (\n      typeof console !== 'undefined' &&\n      console.warn &&\n      typeof ASYNC_VALIDATOR_NO_WARNING === 'undefined'\n    ) {\n      if (errors.every(e => typeof e === 'string')) {\n        console.warn(type, errors);\n      }\n    }\n  };\n}\n\nexport function convertFieldsError(\n  errors: ValidateError[],\n): Record<string, ValidateError[]> {\n  if (!errors || !errors.length) return null;\n  const fields = {};\n  errors.forEach(error => {\n    const field = error.field;\n    fields[field] = fields[field] || [];\n    fields[field].push(error);\n  });\n  return fields;\n}\n\nexport function format(\n  template: ((...args: any[]) => string) | string,\n  ...args: any[]\n): string {\n  let i = 0;\n  const len = args.length;\n  if (typeof template === 'function') {\n    return template.apply(null, args);\n  }\n  if (typeof template === 'string') {\n    let str = template.replace(formatRegExp, x => {\n      if (x === '%%') {\n        return '%';\n      }\n      if (i >= len) {\n        return x;\n      }\n      switch (x) {\n        case '%s':\n          return String(args[i++]);\n        case '%d':\n          return (Number(args[i++]) as unknown) as string;\n        case '%j':\n          try {\n            return JSON.stringify(args[i++]);\n          } catch (_) {\n            return '[Circular]';\n          }\n          break;\n        default:\n          return x;\n      }\n    });\n    return str;\n  }\n  return template;\n}\n\nfunction isNativeStringType(type: string) {\n  return (\n    type === 'string' ||\n    type === 'url' ||\n    type === 'hex' ||\n    type === 'email' ||\n    type === 'date' ||\n    type === 'pattern'\n  );\n}\n\nexport function isEmptyValue(value: Value, type?: string) {\n  if (value === undefined || value === null) {\n    return true;\n  }\n  if (type === 'array' && Array.isArray(value) && !value.length) {\n    return true;\n  }\n  if (isNativeStringType(type) && typeof value === 'string' && !value) {\n    return true;\n  }\n  return false;\n}\n\nexport function isEmptyObject(obj: object) {\n  return Object.keys(obj).length === 0;\n}\n\nfunction asyncParallelArray(\n  arr: RuleValuePackage[],\n  func: ValidateFunc,\n  callback: (errors: ValidateError[]) => void,\n) {\n  const results: ValidateError[] = [];\n  let total = 0;\n  const arrLength = arr.length;\n\n  function count(errors: ValidateError[]) {\n    results.push(...(errors || []));\n    total++;\n    if (total === arrLength) {\n      callback(results);\n    }\n  }\n\n  arr.forEach(a => {\n    func(a, count);\n  });\n}\n\nfunction asyncSerialArray(\n  arr: RuleValuePackage[],\n  func: ValidateFunc,\n  callback: (errors: ValidateError[]) => void,\n) {\n  let index = 0;\n  const arrLength = arr.length;\n\n  function next(errors: ValidateError[]) {\n    if (errors && errors.length) {\n      callback(errors);\n      return;\n    }\n    const original = index;\n    index = index + 1;\n    if (original < arrLength) {\n      func(arr[original], next);\n    } else {\n      callback([]);\n    }\n  }\n\n  next([]);\n}\n\nfunction flattenObjArr(objArr: Record<string, RuleValuePackage[]>) {\n  const ret: RuleValuePackage[] = [];\n  Object.keys(objArr).forEach(k => {\n    ret.push(...(objArr[k] || []));\n  });\n  return ret;\n}\n\nexport class AsyncValidationError extends Error {\n  errors: ValidateError[];\n  fields: Record<string, ValidateError[]>;\n\n  constructor(\n    errors: ValidateError[],\n    fields: Record<string, ValidateError[]>,\n  ) {\n    super('Async Validation Error');\n    this.errors = errors;\n    this.fields = fields;\n  }\n}\n\ntype ValidateFunc = (\n  data: RuleValuePackage,\n  doIt: (errors: ValidateError[]) => void,\n) => void;\n\nexport function asyncMap(\n  objArr: Record<string, RuleValuePackage[]>,\n  option: ValidateOption,\n  func: ValidateFunc,\n  callback: (errors: ValidateError[]) => void,\n  source: Values,\n): Promise<Values> {\n  if (option.first) {\n    const pending = new Promise<Values>((resolve, reject) => {\n      const next = (errors: ValidateError[]) => {\n        callback(errors);\n        return errors.length\n          ? reject(new AsyncValidationError(errors, convertFieldsError(errors)))\n          : resolve(source);\n      };\n      const flattenArr = flattenObjArr(objArr);\n      asyncSerialArray(flattenArr, func, next);\n    });\n    pending.catch(e => e);\n    return pending;\n  }\n  const firstFields =\n    option.firstFields === true\n      ? Object.keys(objArr)\n      : option.firstFields || [];\n\n  const objArrKeys = Object.keys(objArr);\n  const objArrLength = objArrKeys.length;\n  let total = 0;\n  const results: ValidateError[] = [];\n  const pending = new Promise<Values>((resolve, reject) => {\n    const next = (errors: ValidateError[]) => {\n      results.push.apply(results, errors);\n      total++;\n      if (total === objArrLength) {\n        callback(results);\n        return results.length\n          ? reject(\n              new AsyncValidationError(results, convertFieldsError(results)),\n            )\n          : resolve(source);\n      }\n    };\n    if (!objArrKeys.length) {\n      callback(results);\n      resolve(source);\n    }\n    objArrKeys.forEach(key => {\n      const arr = objArr[key];\n      if (firstFields.indexOf(key) !== -1) {\n        asyncSerialArray(arr, func, next);\n      } else {\n        asyncParallelArray(arr, func, next);\n      }\n    });\n  });\n  pending.catch(e => e);\n  return pending;\n}\n\nfunction isErrorObj(\n  obj: ValidateError | string | (() => string),\n): obj is ValidateError {\n  return !!(obj && (obj as ValidateError).message !== undefined);\n}\n\nfunction getValue(value: Values, path: string[]) {\n  let v = value;\n  for (let i = 0; i < path.length; i++) {\n    if (v == undefined) {\n      return v;\n    }\n    v = v[path[i]];\n  }\n  return v;\n}\n\nexport function complementError(rule: InternalRuleItem, source: Values) {\n  return (oe: ValidateError | (() => string) | string): ValidateError => {\n    let fieldValue;\n    if (rule.fullFields) {\n      fieldValue = getValue(source, rule.fullFields);\n    } else {\n      fieldValue = source[(oe as any).field || rule.fullField];\n    }\n    if (isErrorObj(oe)) {\n      oe.field = oe.field || rule.fullField;\n      oe.fieldValue = fieldValue;\n      return oe;\n    }\n    return {\n      message: typeof oe === 'function' ? oe() : oe,\n      fieldValue,\n      field: ((oe as unknown) as ValidateError).field || rule.fullField,\n    };\n  };\n}\n\nexport function deepMerge<T extends object>(target: T, source: Partial<T>): T {\n  if (source) {\n    for (const s in source) {\n      if (source.hasOwnProperty(s)) {\n        const value = source[s];\n        if (typeof value === 'object' && typeof target[s] === 'object') {\n          target[s] = {\n            ...target[s],\n            ...value,\n          };\n        } else {\n          target[s] = value;\n        }\n      }\n    }\n  }\n  return target;\n}\n","import { ExecuteRule } from '../interface';\nimport { format, isEmptyValue } from '../util';\n\nconst required: ExecuteRule = (rule, value, source, errors, options, type) => {\n  if (\n    rule.required &&\n    (!source.hasOwnProperty(rule.field) ||\n      isEmptyValue(value, type || rule.type))\n  ) {\n    errors.push(format(options.messages.required, rule.fullField));\n  }\n};\n\nexport default required;\n","import { ExecuteRule } from '../interface';\nimport { format } from '../util';\n\n/**\n *  Rule for validating whitespace.\n *\n *  @param rule The validation rule.\n *  @param value The value of the field on the source object.\n *  @param source The source object being validated.\n *  @param errors An array of errors that this rule may add\n *  validation errors to.\n *  @param options The validation options.\n *  @param options.messages The validation messages.\n */\nconst whitespace: ExecuteRule = (rule, value, source, errors, options) => {\n  if (/^\\s+$/.test(value) || value === '') {\n    errors.push(format(options.messages.whitespace, rule.fullField));\n  }\n};\n\nexport default whitespace;\n","// https://github.com/kevva/url-regex/blob/master/index.js\nlet urlReg: RegExp;\n\nexport default () => {\n  if (urlReg) {\n    return urlReg;\n  }\n\n  const word = '[a-fA-F\\\\d:]';\n  const b = options =>\n    options && options.includeBoundaries\n      ? `(?:(?<=\\\\s|^)(?=${word})|(?<=${word})(?=\\\\s|$))`\n      : '';\n\n  const v4 =\n    '(?:25[0-5]|2[0-4]\\\\d|1\\\\d\\\\d|[1-9]\\\\d|\\\\d)(?:\\\\.(?:25[0-5]|2[0-4]\\\\d|1\\\\d\\\\d|[1-9]\\\\d|\\\\d)){3}';\n\n  const v6seg = '[a-fA-F\\\\d]{1,4}';\n  const v6 = `\n(?:\n(?:${v6seg}:){7}(?:${v6seg}|:)|                                    // 1:2:3:4:5:6:7::  1:2:3:4:5:6:7:8\n(?:${v6seg}:){6}(?:${v4}|:${v6seg}|:)|                             // 1:2:3:4:5:6::    1:2:3:4:5:6::8   1:2:3:4:5:6::8  1:2:3:4:5:6::1.2.3.4\n(?:${v6seg}:){5}(?::${v4}|(?::${v6seg}){1,2}|:)|                   // 1:2:3:4:5::      1:2:3:4:5::7:8   1:2:3:4:5::8    1:2:3:4:5::7:1.2.3.4\n(?:${v6seg}:){4}(?:(?::${v6seg}){0,1}:${v4}|(?::${v6seg}){1,3}|:)| // 1:2:3:4::        1:2:3:4::6:7:8   1:2:3:4::8      1:2:3:4::6:7:1.2.3.4\n(?:${v6seg}:){3}(?:(?::${v6seg}){0,2}:${v4}|(?::${v6seg}){1,4}|:)| // 1:2:3::          1:2:3::5:6:7:8   1:2:3::8        1:2:3::5:6:7:1.2.3.4\n(?:${v6seg}:){2}(?:(?::${v6seg}){0,3}:${v4}|(?::${v6seg}){1,5}|:)| // 1:2::            1:2::4:5:6:7:8   1:2::8          1:2::4:5:6:7:1.2.3.4\n(?:${v6seg}:){1}(?:(?::${v6seg}){0,4}:${v4}|(?::${v6seg}){1,6}|:)| // 1::              1::3:4:5:6:7:8   1::8            1::3:4:5:6:7:1.2.3.4\n(?::(?:(?::${v6seg}){0,5}:${v4}|(?::${v6seg}){1,7}|:))             // ::2:3:4:5:6:7:8  ::2:3:4:5:6:7:8  ::8             ::1.2.3.4\n)(?:%[0-9a-zA-Z]{1,})?                                             // %eth0            %1\n`\n    .replace(/\\s*\\/\\/.*$/gm, '')\n    .replace(/\\n/g, '')\n    .trim();\n\n  // Pre-compile only the exact regexes because adding a global flag make regexes stateful\n  const v46Exact = new RegExp(`(?:^${v4}$)|(?:^${v6}$)`);\n  const v4exact = new RegExp(`^${v4}$`);\n  const v6exact = new RegExp(`^${v6}$`);\n\n  const ip = options =>\n    options && options.exact\n      ? v46Exact\n      : new RegExp(\n          `(?:${b(options)}${v4}${b(options)})|(?:${b(options)}${v6}${b(\n            options,\n          )})`,\n          'g',\n        );\n\n  ip.v4 = (options?) =>\n    options && options.exact\n      ? v4exact\n      : new RegExp(`${b(options)}${v4}${b(options)}`, 'g');\n  ip.v6 = (options?) =>\n    options && options.exact\n      ? v6exact\n      : new RegExp(`${b(options)}${v6}${b(options)}`, 'g');\n\n  const protocol = `(?:(?:[a-z]+:)?//)`;\n  const auth = '(?:\\\\S+(?::\\\\S*)?@)?';\n  const ipv4 = ip.v4().source;\n  const ipv6 = ip.v6().source;\n  const host = '(?:(?:[a-z\\\\u00a1-\\\\uffff0-9][-_]*)*[a-z\\\\u00a1-\\\\uffff0-9]+)';\n  const domain =\n    '(?:\\\\.(?:[a-z\\\\u00a1-\\\\uffff0-9]-*)*[a-z\\\\u00a1-\\\\uffff0-9]+)*';\n  const tld = `(?:\\\\.(?:[a-z\\\\u00a1-\\\\uffff]{2,}))`;\n  const port = '(?::\\\\d{2,5})?';\n  const path = '(?:[/?#][^\\\\s\"]*)?';\n  const regex = `(?:${protocol}|www\\\\.)${auth}(?:localhost|${ipv4}|${ipv6}|${host}${domain}${tld})${port}${path}`;\n  urlReg = new RegExp(`(?:^${regex}$)`, 'i');\n  return urlReg;\n};\n","import { ExecuteRule, Value } from '../interface';\nimport { format } from '../util';\nimport required from './required';\nimport getUrlRegex from './url';\n/* eslint max-len:0 */\n\nconst pattern = {\n  // http://emailregex.com/\n  email: /^(([^<>()\\[\\]\\\\.,;:\\s@\"]+(\\.[^<>()\\[\\]\\\\.,;:\\s@\"]+)*)|(\".+\"))@((\\[[0-9]{1,3}\\.[0-9]{1,3}\\.[0-9]{1,3}\\.[0-9]{1,3}])|(([a-zA-Z\\-0-9\\u00A0-\\uD7FF\\uF900-\\uFDCF\\uFDF0-\\uFFEF]+\\.)+[a-zA-Z\\u00A0-\\uD7FF\\uF900-\\uFDCF\\uFDF0-\\uFFEF]{2,}))$/,\n  // url: new RegExp(\n  //   '^(?!mailto:)(?:(?:http|https|ftp)://|//)(?:\\\\S+(?::\\\\S*)?@)?(?:(?:(?:[1-9]\\\\d?|1\\\\d\\\\d|2[01]\\\\d|22[0-3])(?:\\\\.(?:1?\\\\d{1,2}|2[0-4]\\\\d|25[0-5])){2}(?:\\\\.(?:[0-9]\\\\d?|1\\\\d\\\\d|2[0-4]\\\\d|25[0-4]))|(?:(?:[a-z\\\\u00a1-\\\\uffff0-9]+-*)*[a-z\\\\u00a1-\\\\uffff0-9]+)(?:\\\\.(?:[a-z\\\\u00a1-\\\\uffff0-9]+-*)*[a-z\\\\u00a1-\\\\uffff0-9]+)*(?:\\\\.(?:[a-z\\\\u00a1-\\\\uffff]{2,})))|localhost)(?::\\\\d{2,5})?(?:(/|\\\\?|#)[^\\\\s]*)?$',\n  //   'i',\n  // ),\n  hex: /^#?([a-f0-9]{6}|[a-f0-9]{3})$/i,\n};\n\nconst types = {\n  integer(value: Value) {\n    return types.number(value) && parseInt(value, 10) === value;\n  },\n  float(value: Value) {\n    return types.number(value) && !types.integer(value);\n  },\n  array(value: Value) {\n    return Array.isArray(value);\n  },\n  regexp(value: Value) {\n    if (value instanceof RegExp) {\n      return true;\n    }\n    try {\n      return !!new RegExp(value);\n    } catch (e) {\n      return false;\n    }\n  },\n  date(value: Value) {\n    return (\n      typeof value.getTime === 'function' &&\n      typeof value.getMonth === 'function' &&\n      typeof value.getYear === 'function' &&\n      !isNaN(value.getTime())\n    );\n  },\n  number(value: Value) {\n    if (isNaN(value)) {\n      return false;\n    }\n    return typeof value === 'number';\n  },\n  object(value: Value) {\n    return typeof value === 'object' && !types.array(value);\n  },\n  method(value: Value) {\n    return typeof value === 'function';\n  },\n  email(value: Value) {\n    return (\n      typeof value === 'string' &&\n      value.length <= 320 &&\n      !!value.match(pattern.email)\n    );\n  },\n  url(value: Value) {\n    return (\n      typeof value === 'string' &&\n      value.length <= 2048 &&\n      !!value.match(getUrlRegex())\n    );\n  },\n  hex(value: Value) {\n    return typeof value === 'string' && !!value.match(pattern.hex);\n  },\n};\n\nconst type: ExecuteRule = (rule, value, source, errors, options) => {\n  if (rule.required && value === undefined) {\n    required(rule, value, source, errors, options);\n    return;\n  }\n  const custom = [\n    'integer',\n    'float',\n    'array',\n    'regexp',\n    'object',\n    'method',\n    'email',\n    'number',\n    'date',\n    'url',\n    'hex',\n  ];\n  const ruleType = rule.type;\n  if (custom.indexOf(ruleType) > -1) {\n    if (!types[ruleType](value)) {\n      errors.push(\n        format(options.messages.types[ruleType], rule.fullField, rule.type),\n      );\n    }\n    // straight typeof check\n  } else if (ruleType && typeof value !== rule.type) {\n    errors.push(\n      format(options.messages.types[ruleType], rule.fullField, rule.type),\n    );\n  }\n};\n\nexport default type;\n","import { ExecuteRule } from '../interface';\nimport { format } from '../util';\n\nconst range: ExecuteRule = (rule, value, source, errors, options) => {\n  const len = typeof rule.len === 'number';\n  const min = typeof rule.min === 'number';\n  const max = typeof rule.max === 'number';\n  // 正则匹配码点范围从U+010000一直到U+10FFFF的文字（补充平面Supplementary Plane）\n  const spRegexp = /[\\uD800-\\uDBFF][\\uDC00-\\uDFFF]/g;\n  let val = value;\n  let key = null;\n  const num = typeof value === 'number';\n  const str = typeof value === 'string';\n  const arr = Array.isArray(value);\n  if (num) {\n    key = 'number';\n  } else if (str) {\n    key = 'string';\n  } else if (arr) {\n    key = 'array';\n  }\n  // if the value is not of a supported type for range validation\n  // the validation rule rule should use the\n  // type property to also test for a particular type\n  if (!key) {\n    return false;\n  }\n  if (arr) {\n    val = value.length;\n  }\n  if (str) {\n    // 处理码点大于U+010000的文字length属性不准确的bug，如\"𠮷𠮷𠮷\".lenght !== 3\n    val = value.replace(spRegexp, '_').length;\n  }\n  if (len) {\n    if (val !== rule.len) {\n      errors.push(format(options.messages[key].len, rule.fullField, rule.len));\n    }\n  } else if (min && !max && val < rule.min) {\n    errors.push(format(options.messages[key].min, rule.fullField, rule.min));\n  } else if (max && !min && val > rule.max) {\n    errors.push(format(options.messages[key].max, rule.fullField, rule.max));\n  } else if (min && max && (val < rule.min || val > rule.max)) {\n    errors.push(\n      format(options.messages[key].range, rule.fullField, rule.min, rule.max),\n    );\n  }\n};\n\nexport default range;\n","import { ExecuteRule } from '../interface';\nimport { format } from '../util';\n\nconst ENUM = 'enum' as const;\n\nconst enumerable: ExecuteRule = (rule, value, source, errors, options) => {\n  rule[ENUM] = Array.isArray(rule[ENUM]) ? rule[ENUM] : [];\n  if (rule[ENUM].indexOf(value) === -1) {\n    errors.push(\n      format(options.messages[ENUM], rule.fullField, rule[ENUM].join(', ')),\n    );\n  }\n};\n\nexport default enumerable;\n","import { ExecuteRule } from '../interface';\nimport { format } from '../util';\n\nconst pattern: ExecuteRule = (rule, value, source, errors, options) => {\n  if (rule.pattern) {\n    if (rule.pattern instanceof RegExp) {\n      // if a RegExp instance is passed, reset `lastIndex` in case its `global`\n      // flag is accidentally set to `true`, which in a validation scenario\n      // is not necessary and the result might be misleading\n      rule.pattern.lastIndex = 0;\n      if (!rule.pattern.test(value)) {\n        errors.push(\n          format(\n            options.messages.pattern.mismatch,\n            rule.fullField,\n            value,\n            rule.pattern,\n          ),\n        );\n      }\n    } else if (typeof rule.pattern === 'string') {\n      const _pattern = new RegExp(rule.pattern);\n      if (!_pattern.test(value)) {\n        errors.push(\n          format(\n            options.messages.pattern.mismatch,\n            rule.fullField,\n            value,\n            rule.pattern,\n          ),\n        );\n      }\n    }\n  }\n};\n\nexport default pattern;\n","import required from './required';\nimport whitespace from './whitespace';\nimport type from './type';\nimport range from './range';\nimport enumRule from './enum';\nimport pattern from './pattern';\n\nexport default {\n  required,\n  whitespace,\n  type,\n  range,\n  enum: enumRule,\n  pattern,\n};\n","import { ExecuteValidator } from '../interface';\nimport rules from '../rule';\nimport { isEmptyValue } from '../util';\n\nconst string: ExecuteValidator = (rule, value, callback, source, options) => {\n  const errors: string[] = [];\n  const validate =\n    rule.required || (!rule.required && source.hasOwnProperty(rule.field));\n  if (validate) {\n    if (isEmptyValue(value, 'string') && !rule.required) {\n      return callback();\n    }\n    rules.required(rule, value, source, errors, options, 'string');\n    if (!isEmptyValue(value, 'string')) {\n      rules.type(rule, value, source, errors, options);\n      rules.range(rule, value, source, errors, options);\n      rules.pattern(rule, value, source, errors, options);\n      if (rule.whitespace === true) {\n        rules.whitespace(rule, value, source, errors, options);\n      }\n    }\n  }\n  callback(errors);\n};\n\nexport default string;\n","import { ExecuteValidator } from '../interface';\nimport rules from '../rule';\nimport { isEmptyValue } from '../util';\n\nconst method: ExecuteValidator = (rule, value, callback, source, options) => {\n  const errors: string[] = [];\n  const validate =\n    rule.required || (!rule.required && source.hasOwnProperty(rule.field));\n  if (validate) {\n    if (isEmptyValue(value) && !rule.required) {\n      return callback();\n    }\n    rules.required(rule, value, source, errors, options);\n    if (value !== undefined) {\n      rules.type(rule, value, source, errors, options);\n    }\n  }\n  callback(errors);\n};\n\nexport default method;\n","import { ExecuteValidator } from '../interface';\nimport rules from '../rule';\nimport { isEmptyValue } from '../util';\n\nconst number: ExecuteValidator = (rule, value, callback, source, options) => {\n  const errors: string[] = [];\n  const validate =\n    rule.required || (!rule.required && source.hasOwnProperty(rule.field));\n  if (validate) {\n    if (value === '') {\n      value = undefined;\n    }\n    if (isEmptyValue(value) && !rule.required) {\n      return callback();\n    }\n    rules.required(rule, value, source, errors, options);\n    if (value !== undefined) {\n      rules.type(rule, value, source, errors, options);\n      rules.range(rule, value, source, errors, options);\n    }\n  }\n  callback(errors);\n};\n\nexport default number;\n","import { isEmptyValue } from '../util';\nimport rules from '../rule';\nimport { ExecuteValidator } from '../interface';\n\nconst boolean: ExecuteValidator = (rule, value, callback, source, options) => {\n  const errors: string[] = [];\n  const validate =\n    rule.required || (!rule.required && source.hasOwnProperty(rule.field));\n  if (validate) {\n    if (isEmptyValue(value) && !rule.required) {\n      return callback();\n    }\n    rules.required(rule, value, source, errors, options);\n    if (value !== undefined) {\n      rules.type(rule, value, source, errors, options);\n    }\n  }\n  callback(errors);\n};\n\nexport default boolean;\n","import { ExecuteValidator } from '../interface';\nimport rules from '../rule';\nimport { isEmptyValue } from '../util';\n\nconst regexp: ExecuteValidator = (rule, value, callback, source, options) => {\n  const errors: string[] = [];\n  const validate =\n    rule.required || (!rule.required && source.hasOwnProperty(rule.field));\n  if (validate) {\n    if (isEmptyValue(value) && !rule.required) {\n      return callback();\n    }\n    rules.required(rule, value, source, errors, options);\n    if (!isEmptyValue(value)) {\n      rules.type(rule, value, source, errors, options);\n    }\n  }\n  callback(errors);\n};\n\nexport default regexp;\n","import { ExecuteValidator } from '../interface';\nimport rules from '../rule';\nimport { isEmptyValue } from '../util';\n\nconst integer: ExecuteValidator = (rule, value, callback, source, options) => {\n  const errors: string[] = [];\n  const validate =\n    rule.required || (!rule.required && source.hasOwnProperty(rule.field));\n  if (validate) {\n    if (isEmptyValue(value) && !rule.required) {\n      return callback();\n    }\n    rules.required(rule, value, source, errors, options);\n    if (value !== undefined) {\n      rules.type(rule, value, source, errors, options);\n      rules.range(rule, value, source, errors, options);\n    }\n  }\n  callback(errors);\n};\n\nexport default integer;\n","import { ExecuteValidator } from '../interface';\nimport rules from '../rule';\nimport { isEmptyValue } from '../util';\n\nconst floatFn: ExecuteValidator = (rule, value, callback, source, options) => {\n  const errors: string[] = [];\n  const validate =\n    rule.required || (!rule.required && source.hasOwnProperty(rule.field));\n  if (validate) {\n    if (isEmptyValue(value) && !rule.required) {\n      return callback();\n    }\n    rules.required(rule, value, source, errors, options);\n    if (value !== undefined) {\n      rules.type(rule, value, source, errors, options);\n      rules.range(rule, value, source, errors, options);\n    }\n  }\n  callback(errors);\n};\n\nexport default floatFn;\n","import { ExecuteValidator } from '../interface';\nimport rules from '../rule/index';\n\nconst array: ExecuteValidator = (rule, value, callback, source, options) => {\n  const errors: string[] = [];\n  const validate =\n    rule.required || (!rule.required && source.hasOwnProperty(rule.field));\n  if (validate) {\n    if ((value === undefined || value === null) && !rule.required) {\n      return callback();\n    }\n    rules.required(rule, value, source, errors, options, 'array');\n    if (value !== undefined && value !== null) {\n      rules.type(rule, value, source, errors, options);\n      rules.range(rule, value, source, errors, options);\n    }\n  }\n  callback(errors);\n};\n\nexport default array;\n","import { ExecuteValidator } from '../interface';\nimport rules from '../rule';\nimport { isEmptyValue } from '../util';\n\nconst object: ExecuteValidator = (rule, value, callback, source, options) => {\n  const errors: string[] = [];\n  const validate =\n    rule.required || (!rule.required && source.hasOwnProperty(rule.field));\n  if (validate) {\n    if (isEmptyValue(value) && !rule.required) {\n      return callback();\n    }\n    rules.required(rule, value, source, errors, options);\n    if (value !== undefined) {\n      rules.type(rule, value, source, errors, options);\n    }\n  }\n  callback(errors);\n};\n\nexport default object;\n","import { ExecuteValidator } from '../interface';\nimport rules from '../rule';\nimport { isEmptyValue } from '../util';\n\nconst ENUM = 'enum' as const;\n\nconst enumerable: ExecuteValidator = (\n  rule,\n  value,\n  callback,\n  source,\n  options,\n) => {\n  const errors: string[] = [];\n  const validate =\n    rule.required || (!rule.required && source.hasOwnProperty(rule.field));\n  if (validate) {\n    if (isEmptyValue(value) && !rule.required) {\n      return callback();\n    }\n    rules.required(rule, value, source, errors, options);\n    if (value !== undefined) {\n      rules[ENUM](rule, value, source, errors, options);\n    }\n  }\n  callback(errors);\n};\n\nexport default enumerable;\n","import { ExecuteValidator } from '../interface';\nimport rules from '../rule';\nimport { isEmptyValue } from '../util';\n\nconst pattern: ExecuteValidator = (rule, value, callback, source, options) => {\n  const errors: string[] = [];\n  const validate =\n    rule.required || (!rule.required && source.hasOwnProperty(rule.field));\n  if (validate) {\n    if (isEmptyValue(value, 'string') && !rule.required) {\n      return callback();\n    }\n    rules.required(rule, value, source, errors, options);\n    if (!isEmptyValue(value, 'string')) {\n      rules.pattern(rule, value, source, errors, options);\n    }\n  }\n  callback(errors);\n};\n\nexport default pattern;\n","import { ExecuteValidator } from '../interface';\nimport rules from '../rule';\nimport { isEmptyValue } from '../util';\n\nconst date: ExecuteValidator = (rule, value, callback, source, options) => {\n  // console.log('integer rule called %j', rule);\n  const errors: string[] = [];\n  const validate =\n    rule.required || (!rule.required && source.hasOwnProperty(rule.field));\n  // console.log('validate on %s value', value);\n  if (validate) {\n    if (isEmptyValue(value, 'date') && !rule.required) {\n      return callback();\n    }\n    rules.required(rule, value, source, errors, options);\n    if (!isEmptyValue(value, 'date')) {\n      let dateObject;\n\n      if (value instanceof Date) {\n        dateObject = value;\n      } else {\n        dateObject = new Date(value);\n      }\n\n      rules.type(rule, dateObject, source, errors, options);\n      if (dateObject) {\n        rules.range(rule, dateObject.getTime(), source, errors, options);\n      }\n    }\n  }\n  callback(errors);\n};\n\nexport default date;\n","import { ExecuteValidator } from '../interface';\nimport rules from '../rule';\n\nconst required: ExecuteValidator = (rule, value, callback, source, options) => {\n  const errors: string[] = [];\n  const type = Array.isArray(value) ? 'array' : typeof value;\n  rules.required(rule, value, source, errors, options, type);\n  callback(errors);\n};\n\nexport default required;\n","import { ExecuteValidator } from '../interface';\nimport rules from '../rule';\nimport { isEmptyValue } from '../util';\n\nconst type: ExecuteValidator = (rule, value, callback, source, options) => {\n  const ruleType = rule.type;\n  const errors: string[] = [];\n  const validate =\n    rule.required || (!rule.required && source.hasOwnProperty(rule.field));\n  if (validate) {\n    if (isEmptyValue(value, ruleType) && !rule.required) {\n      return callback();\n    }\n    rules.required(rule, value, source, errors, options, ruleType);\n    if (!isEmptyValue(value, ruleType)) {\n      rules.type(rule, value, source, errors, options);\n    }\n  }\n  callback(errors);\n};\n\nexport default type;\n","import { ExecuteValidator } from '../interface';\nimport rules from '../rule';\nimport { isEmptyValue } from '../util';\n\nconst any: ExecuteValidator = (rule, value, callback, source, options) => {\n  const errors: string[] = [];\n  const validate =\n    rule.required || (!rule.required && source.hasOwnProperty(rule.field));\n  if (validate) {\n    if (isEmptyValue(value) && !rule.required) {\n      return callback();\n    }\n    rules.required(rule, value, source, errors, options);\n  }\n  callback(errors);\n};\n\nexport default any;\n","import string from './string';\nimport method from './method';\nimport number from './number';\nimport boolean from './boolean';\nimport regexp from './regexp';\nimport integer from './integer';\nimport float from './float';\nimport array from './array';\nimport object from './object';\nimport enumValidator from './enum';\nimport pattern from './pattern';\nimport date from './date';\nimport required from './required';\nimport type from './type';\nimport any from './any';\n\nexport default {\n  string,\n  method,\n  number,\n  boolean,\n  regexp,\n  integer,\n  float,\n  array,\n  object,\n  enum: enumValidator,\n  pattern,\n  date,\n  url: type,\n  hex: type,\n  email: type,\n  required,\n  any,\n};\n","import { InternalValidateMessages } from './interface';\n\nexport function newMessages(): InternalValidateMessages {\n  return {\n    default: 'Validation error on field %s',\n    required: '%s is required',\n    enum: '%s must be one of %s',\n    whitespace: '%s cannot be empty',\n    date: {\n      format: '%s date %s is invalid for format %s',\n      parse: '%s date could not be parsed, %s is invalid ',\n      invalid: '%s date %s is invalid',\n    },\n    types: {\n      string: '%s is not a %s',\n      method: '%s is not a %s (function)',\n      array: '%s is not an %s',\n      object: '%s is not an %s',\n      number: '%s is not a %s',\n      date: '%s is not a %s',\n      boolean: '%s is not a %s',\n      integer: '%s is not an %s',\n      float: '%s is not a %s',\n      regexp: '%s is not a valid %s',\n      email: '%s is not a valid %s',\n      url: '%s is not a valid %s',\n      hex: '%s is not a valid %s',\n    },\n    string: {\n      len: '%s must be exactly %s characters',\n      min: '%s must be at least %s characters',\n      max: '%s cannot be longer than %s characters',\n      range: '%s must be between %s and %s characters',\n    },\n    number: {\n      len: '%s must equal %s',\n      min: '%s cannot be less than %s',\n      max: '%s cannot be greater than %s',\n      range: '%s must be between %s and %s',\n    },\n    array: {\n      len: '%s must be exactly %s in length',\n      min: '%s cannot be less than %s in length',\n      max: '%s cannot be greater than %s in length',\n      range: '%s must be between %s and %s in length',\n    },\n    pattern: {\n      mismatch: '%s value %s does not match pattern %s',\n    },\n    clone() {\n      const cloned = JSON.parse(JSON.stringify(this));\n      cloned.clone = this.clone;\n      return cloned;\n    },\n  };\n}\n\nexport const messages = newMessages();\n","import {\n  format,\n  complementError,\n  asyncMap,\n  warning,\n  deepMerge,\n  convertFieldsError,\n} from './util';\nimport validators from './validator/index';\nimport { messages as defaultMessages, newMessages } from './messages';\nimport {\n  InternalRuleItem,\n  InternalValidateMessages,\n  Rule,\n  RuleItem,\n  Rules,\n  ValidateCallback,\n  ValidateMessages,\n  ValidateOption,\n  Values,\n  RuleValuePackage,\n  ValidateError,\n  ValidateFieldsError,\n  SyncErrorType,\n  ValidateResult,\n} from './interface';\n\nexport * from './interface';\n\n/**\n *  Encapsulates a validation schema.\n *\n *  @param descriptor An object declaring validation rules\n *  for this schema.\n */\nclass Schema {\n  // ========================= Static =========================\n  static register = function register(type: string, validator) {\n    if (typeof validator !== 'function') {\n      throw new Error(\n        'Cannot register a validator by type, validator is not a function',\n      );\n    }\n    validators[type] = validator;\n  };\n\n  static warning = warning;\n\n  static messages = defaultMessages;\n\n  static validators = validators;\n\n  // ======================== Instance ========================\n  rules: Record<string, RuleItem[]> = null;\n  _messages: InternalValidateMessages = defaultMessages;\n\n  constructor(descriptor: Rules) {\n    this.define(descriptor);\n  }\n\n  define(rules: Rules) {\n    if (!rules) {\n      throw new Error('Cannot configure a schema with no rules');\n    }\n    if (typeof rules !== 'object' || Array.isArray(rules)) {\n      throw new Error('Rules must be an object');\n    }\n    this.rules = {};\n\n    Object.keys(rules).forEach(name => {\n      const item: Rule = rules[name];\n      this.rules[name] = Array.isArray(item) ? item : [item];\n    });\n  }\n\n  messages(messages?: ValidateMessages) {\n    if (messages) {\n      this._messages = deepMerge(newMessages(), messages);\n    }\n    return this._messages;\n  }\n\n  validate(\n    source: Values,\n    option?: ValidateOption,\n    callback?: ValidateCallback,\n  ): Promise<Values>;\n  validate(source: Values, callback: ValidateCallback): Promise<Values>;\n  validate(source: Values): Promise<Values>;\n\n  validate(source_: Values, o: any = {}, oc: any = () => {}): Promise<Values> {\n    let source: Values = source_;\n    let options: ValidateOption = o;\n    let callback: ValidateCallback = oc;\n    if (typeof options === 'function') {\n      callback = options;\n      options = {};\n    }\n    if (!this.rules || Object.keys(this.rules).length === 0) {\n      if (callback) {\n        callback(null, source);\n      }\n      return Promise.resolve(source);\n    }\n\n    function complete(results: (ValidateError | ValidateError[])[]) {\n      let errors: ValidateError[] = [];\n      let fields: ValidateFieldsError = {};\n\n      function add(e: ValidateError | ValidateError[]) {\n        if (Array.isArray(e)) {\n          errors = errors.concat(...e);\n        } else {\n          errors.push(e);\n        }\n      }\n\n      for (let i = 0; i < results.length; i++) {\n        add(results[i]);\n      }\n      if (!errors.length) {\n        callback(null, source);\n      } else {\n        fields = convertFieldsError(errors);\n        (callback as (\n          errors: ValidateError[],\n          fields: ValidateFieldsError,\n        ) => void)(errors, fields);\n      }\n    }\n\n    if (options.messages) {\n      let messages = this.messages();\n      if (messages === defaultMessages) {\n        messages = newMessages();\n      }\n      deepMerge(messages, options.messages);\n      options.messages = messages;\n    } else {\n      options.messages = this.messages();\n    }\n\n    const series: Record<string, RuleValuePackage[]> = {};\n    const keys = options.keys || Object.keys(this.rules);\n    keys.forEach(z => {\n      const arr = this.rules[z];\n      let value = source[z];\n      arr.forEach(r => {\n        let rule: InternalRuleItem = r;\n        if (typeof rule.transform === 'function') {\n          if (source === source_) {\n            source = { ...source };\n          }\n          value = source[z] = rule.transform(value);\n        }\n        if (typeof rule === 'function') {\n          rule = {\n            validator: rule,\n          };\n        } else {\n          rule = { ...rule };\n        }\n\n        // Fill validator. Skip if nothing need to validate\n        rule.validator = this.getValidationMethod(rule);\n        if (!rule.validator) {\n          return;\n        }\n\n        rule.field = z;\n        rule.fullField = rule.fullField || z;\n        rule.type = this.getType(rule);\n        series[z] = series[z] || [];\n        series[z].push({\n          rule,\n          value,\n          source,\n          field: z,\n        });\n      });\n    });\n    const errorFields = {};\n    return asyncMap(\n      series,\n      options,\n      (data, doIt) => {\n        const rule = data.rule;\n        let deep =\n          (rule.type === 'object' || rule.type === 'array') &&\n          (typeof rule.fields === 'object' ||\n            typeof rule.defaultField === 'object');\n        deep = deep && (rule.required || (!rule.required && data.value));\n        rule.field = data.field;\n\n        function addFullField(key: string, schema: RuleItem) {\n          return {\n            ...schema,\n            fullField: `${rule.fullField}.${key}`,\n            fullFields: rule.fullFields ? [...rule.fullFields, key] : [key],\n          };\n        }\n\n        function cb(e: SyncErrorType | SyncErrorType[] = []) {\n          let errorList = Array.isArray(e) ? e : [e];\n          if (!options.suppressWarning && errorList.length) {\n            Schema.warning('async-validator:', errorList);\n          }\n          if (errorList.length && rule.message !== undefined) {\n            errorList = [].concat(rule.message);\n          }\n\n          // Fill error info\n          let filledErrors = errorList.map(complementError(rule, source));\n\n          if (options.first && filledErrors.length) {\n            errorFields[rule.field] = 1;\n            return doIt(filledErrors);\n          }\n          if (!deep) {\n            doIt(filledErrors);\n          } else {\n            // if rule is required but the target object\n            // does not exist fail at the rule level and don't\n            // go deeper\n            if (rule.required && !data.value) {\n              if (rule.message !== undefined) {\n                filledErrors = []\n                  .concat(rule.message)\n                  .map(complementError(rule, source));\n              } else if (options.error) {\n                filledErrors = [\n                  options.error(\n                    rule,\n                    format(options.messages.required, rule.field),\n                  ),\n                ];\n              }\n              return doIt(filledErrors);\n            }\n\n            let fieldsSchema: Record<string, Rule> = {};\n            if (rule.defaultField) {\n              Object.keys(data.value).map(key => {\n                fieldsSchema[key] = rule.defaultField;\n              });\n            }\n            fieldsSchema = {\n              ...fieldsSchema,\n              ...data.rule.fields,\n            };\n\n            const paredFieldsSchema: Record<string, RuleItem[]> = {};\n\n            Object.keys(fieldsSchema).forEach(field => {\n              const fieldSchema = fieldsSchema[field];\n              const fieldSchemaList = Array.isArray(fieldSchema)\n                ? fieldSchema\n                : [fieldSchema];\n              paredFieldsSchema[field] = fieldSchemaList.map(\n                addFullField.bind(null, field),\n              );\n            });\n            const schema = new Schema(paredFieldsSchema);\n            schema.messages(options.messages);\n            if (data.rule.options) {\n              data.rule.options.messages = options.messages;\n              data.rule.options.error = options.error;\n            }\n            schema.validate(data.value, data.rule.options || options, errs => {\n              const finalErrors = [];\n              if (filledErrors && filledErrors.length) {\n                finalErrors.push(...filledErrors);\n              }\n              if (errs && errs.length) {\n                finalErrors.push(...errs);\n              }\n              doIt(finalErrors.length ? finalErrors : null);\n            });\n          }\n        }\n\n        let res: ValidateResult;\n        if (rule.asyncValidator) {\n          res = rule.asyncValidator(rule, data.value, cb, data.source, options);\n        } else if (rule.validator) {\n          try {\n            res = rule.validator(rule, data.value, cb, data.source, options);\n          } catch (error) {\n            console.error?.(error);\n            // rethrow to report error\n            if (!options.suppressValidatorError) {\n              setTimeout(() => {\n                throw error;\n              }, 0);\n            }\n            cb(error.message);\n          }\n          if (res === true) {\n            cb();\n          } else if (res === false) {\n            cb(\n              typeof rule.message === 'function'\n                ? rule.message(rule.fullField || rule.field)\n                : rule.message || `${rule.fullField || rule.field} fails`,\n            );\n          } else if (res instanceof Array) {\n            cb(res);\n          } else if (res instanceof Error) {\n            cb(res.message);\n          }\n        }\n        if (res && (res as Promise<void>).then) {\n          (res as Promise<void>).then(\n            () => cb(),\n            e => cb(e),\n          );\n        }\n      },\n      results => {\n        complete(results);\n      },\n      source,\n    );\n  }\n\n  getType(rule: InternalRuleItem) {\n    if (rule.type === undefined && rule.pattern instanceof RegExp) {\n      rule.type = 'pattern';\n    }\n    if (\n      typeof rule.validator !== 'function' &&\n      rule.type &&\n      !validators.hasOwnProperty(rule.type)\n    ) {\n      throw new Error(format('Unknown rule type %s', rule.type));\n    }\n    return rule.type || 'string';\n  }\n\n  getValidationMethod(rule: InternalRuleItem) {\n    if (typeof rule.validator === 'function') {\n      return rule.validator;\n    }\n    const keys = Object.keys(rule);\n    const messageIndex = keys.indexOf('message');\n    if (messageIndex !== -1) {\n      keys.splice(messageIndex, 1);\n    }\n    if (keys.length === 1 && keys[0] === 'required') {\n      return validators.required;\n    }\n    return validators[this.getType(rule)] || undefined;\n  }\n}\n\nexport default Schema;\n"]},"metadata":{},"sourceType":"module"}