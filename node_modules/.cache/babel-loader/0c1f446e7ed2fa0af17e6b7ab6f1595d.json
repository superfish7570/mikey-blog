{"ast":null,"code":"var _jsxFileName = \"/Users/mikey/Desktop/yc-blog/src/admin/components/areaList/AreaList.jsx\",\n    _s = $RefreshSig$();\n\nimport React, { useState, useImperativeHandle, forwardRef, createRef, useMemo, useEffect } from 'react';\nimport styles from './style.module.scss';\nimport { Button } from \"antd\";\nimport { AreaItem } from \"../areaItem\";\nimport { jsxDEV as _jsxDEV } from \"react/jsx-dev-runtime\";\nlet refs = [];\nexport const AreaList = /*#__PURE__*/forwardRef(_c = _s((props, ref) => {\n  _s();\n\n  const [children, setChildren] = useState(props.children); // 感知外部 schema 变化 如果children发生了改变 调用 setChildren 外部发生变化 children就发生变化了\n\n  useEffect(() => {\n    setChildren(props.children);\n  }, [props.children]); // 为了每次渲染时候性能高一些 ,不希望它重复的反复的渲染 做一下缓存或者说性能优化 用了 useMemo\n\n  useMemo(() => {\n    refs = children.map(item => /*#__PURE__*/createRef());\n  }, [children]); // 增加\n\n  const addItemToChildren = () => {\n    const newChildren = [...children];\n    newChildren.push({});\n    setChildren(newChildren);\n  }; // 删除 这里给 子组件使用 就是 AreaItem 通过子组件标签 赋值传递\n\n\n  const removeItemFromChildren = index => {\n    const newChildren = [...children];\n    newChildren.splice(index, 1);\n    setChildren(newChildren);\n  }; // ref\n\n\n  useImperativeHandle(ref, () => {\n    return {\n      // 给父组件提供的一个方法  当你调用我的时候 我会知道我有几个children 然后去循环 在从每个children每个子组件的时候在去\n      // 获取schema 拼接获取给上层的组件 也就是一层一层的传递 这边就是传递给了 HomeManagePage了\n      getSchema: () => {\n        // 只负责 管理 children这一层 , 你问我下一层组件存的是什么，我也不知道, 所以这边在通过children,调用下一层的\n        // getSchema 然后去把对应的内容 返给上一层  只要为了后面好维护, 那一个层级有问题 找那一层级的问题就好了\n        const schema = [];\n        children.forEach((item, index) => {\n          schema.push(refs[index].current.getSchema());\n        });\n        return schema;\n      }\n    };\n  });\n  return /*#__PURE__*/_jsxDEV(\"div\", {\n    children: [/*#__PURE__*/_jsxDEV(\"ul\", {\n      className: styles.list,\n      children: children.map((item, index) => /*#__PURE__*/_jsxDEV(AreaItem, {\n        item: item,\n        index: index,\n        removeItemFromChildren: removeItemFromChildren,\n        ref: refs[index]\n      }, index, false, {\n        fileName: _jsxFileName,\n        lineNumber: 56,\n        columnNumber: 21\n      }, this))\n    }, void 0, false, {\n      fileName: _jsxFileName,\n      lineNumber: 54,\n      columnNumber: 13\n    }, this), /*#__PURE__*/_jsxDEV(Button, {\n      type: \"primary\",\n      ghost: true,\n      onClick: addItemToChildren,\n      children: \"\\u65B0\\u589E\\u533A\\u5757\\u6309\\u94AE\"\n    }, void 0, false, {\n      fileName: _jsxFileName,\n      lineNumber: 62,\n      columnNumber: 13\n    }, this)]\n  }, void 0, true, {\n    fileName: _jsxFileName,\n    lineNumber: 53,\n    columnNumber: 9\n  }, this);\n}, \"XWxgnjCdam9HzTBsUy/aroQw1Lg=\", false, function () {\n  return [useImperativeHandle];\n}));\n_c2 = AreaList;\n\nvar _c, _c2;\n\n$RefreshReg$(_c, \"AreaList$forwardRef\");\n$RefreshReg$(_c2, \"AreaList\");","map":{"version":3,"names":["React","useState","useImperativeHandle","forwardRef","createRef","useMemo","useEffect","styles","Button","AreaItem","refs","AreaList","props","ref","children","setChildren","map","item","addItemToChildren","newChildren","push","removeItemFromChildren","index","splice","getSchema","schema","forEach","current","list"],"sources":["/Users/mikey/Desktop/yc-blog/src/admin/components/areaList/AreaList.jsx"],"sourcesContent":["import React, {useState, useImperativeHandle, forwardRef, createRef, useMemo, useEffect} from 'react';\nimport styles from './style.module.scss';\nimport {Button} from \"antd\";\nimport {AreaItem} from \"../areaItem\";\n\nlet refs = [];\n\nexport const AreaList = forwardRef((props, ref) => {\n    const [children, setChildren] = useState(props.children);\n\n    // 感知外部 schema 变化 如果children发生了改变 调用 setChildren 外部发生变化 children就发生变化了\n    useEffect(() => {\n        setChildren(props.children);\n    }, [props.children])\n\n    // 为了每次渲染时候性能高一些 ,不希望它重复的反复的渲染 做一下缓存或者说性能优化 用了 useMemo\n    useMemo(() => {\n        refs = children.map(item => createRef());\n    }, [children])\n\n    // 增加\n    const addItemToChildren = () => {\n        const newChildren = [...children];\n        newChildren.push({});\n        setChildren(newChildren);\n    }\n\n    // 删除 这里给 子组件使用 就是 AreaItem 通过子组件标签 赋值传递\n    const removeItemFromChildren = (index) => {\n        const newChildren = [...children];\n        newChildren.splice(index, 1);\n        setChildren(newChildren);\n    }\n\n    // ref\n    useImperativeHandle(ref, () => {\n        return {\n            // 给父组件提供的一个方法  当你调用我的时候 我会知道我有几个children 然后去循环 在从每个children每个子组件的时候在去\n            // 获取schema 拼接获取给上层的组件 也就是一层一层的传递 这边就是传递给了 HomeManagePage了\n            getSchema: () => {\n                // 只负责 管理 children这一层 , 你问我下一层组件存的是什么，我也不知道, 所以这边在通过children,调用下一层的\n                // getSchema 然后去把对应的内容 返给上一层  只要为了后面好维护, 那一个层级有问题 找那一层级的问题就好了\n                const schema = [];\n                children.forEach((item, index) => {\n                    schema.push(refs[index].current.getSchema());\n                })\n                return schema;\n            }\n        };\n    })\n\n    return (\n        <div>\n            <ul className={styles.list}>\n                {children.map((item, index) => (\n                    <AreaItem key={index} item={item} index={index}\n                              removeItemFromChildren={removeItemFromChildren}\n                              ref={refs[index]}\n                    />\n                ))}\n            </ul>\n            <Button type='primary' ghost onClick={addItemToChildren}>新增区块按钮</Button>\n        </div>\n    )\n})"],"mappings":";;;AAAA,OAAOA,KAAP,IAAeC,QAAf,EAAyBC,mBAAzB,EAA8CC,UAA9C,EAA0DC,SAA1D,EAAqEC,OAArE,EAA8EC,SAA9E,QAA8F,OAA9F;AACA,OAAOC,MAAP,MAAmB,qBAAnB;AACA,SAAQC,MAAR,QAAqB,MAArB;AACA,SAAQC,QAAR,QAAuB,aAAvB;;AAEA,IAAIC,IAAI,GAAG,EAAX;AAEA,OAAO,MAAMC,QAAQ,gBAAGR,UAAU,SAAC,CAACS,KAAD,EAAQC,GAAR,KAAgB;EAAA;;EAC/C,MAAM,CAACC,QAAD,EAAWC,WAAX,IAA0Bd,QAAQ,CAACW,KAAK,CAACE,QAAP,CAAxC,CAD+C,CAG/C;;EACAR,SAAS,CAAC,MAAM;IACZS,WAAW,CAACH,KAAK,CAACE,QAAP,CAAX;EACH,CAFQ,EAEN,CAACF,KAAK,CAACE,QAAP,CAFM,CAAT,CAJ+C,CAQ/C;;EACAT,OAAO,CAAC,MAAM;IACVK,IAAI,GAAGI,QAAQ,CAACE,GAAT,CAAaC,IAAI,iBAAIb,SAAS,EAA9B,CAAP;EACH,CAFM,EAEJ,CAACU,QAAD,CAFI,CAAP,CAT+C,CAa/C;;EACA,MAAMI,iBAAiB,GAAG,MAAM;IAC5B,MAAMC,WAAW,GAAG,CAAC,GAAGL,QAAJ,CAApB;IACAK,WAAW,CAACC,IAAZ,CAAiB,EAAjB;IACAL,WAAW,CAACI,WAAD,CAAX;EACH,CAJD,CAd+C,CAoB/C;;;EACA,MAAME,sBAAsB,GAAIC,KAAD,IAAW;IACtC,MAAMH,WAAW,GAAG,CAAC,GAAGL,QAAJ,CAApB;IACAK,WAAW,CAACI,MAAZ,CAAmBD,KAAnB,EAA0B,CAA1B;IACAP,WAAW,CAACI,WAAD,CAAX;EACH,CAJD,CArB+C,CA2B/C;;;EACAjB,mBAAmB,CAACW,GAAD,EAAM,MAAM;IAC3B,OAAO;MACH;MACA;MACAW,SAAS,EAAE,MAAM;QACb;QACA;QACA,MAAMC,MAAM,GAAG,EAAf;QACAX,QAAQ,CAACY,OAAT,CAAiB,CAACT,IAAD,EAAOK,KAAP,KAAiB;UAC9BG,MAAM,CAACL,IAAP,CAAYV,IAAI,CAACY,KAAD,CAAJ,CAAYK,OAAZ,CAAoBH,SAApB,EAAZ;QACH,CAFD;QAGA,OAAOC,MAAP;MACH;IAXE,CAAP;EAaH,CAdkB,CAAnB;EAgBA,oBACI;IAAA,wBACI;MAAI,SAAS,EAAElB,MAAM,CAACqB,IAAtB;MAAA,UACKd,QAAQ,CAACE,GAAT,CAAa,CAACC,IAAD,EAAOK,KAAP,kBACV,QAAC,QAAD;QAAsB,IAAI,EAAEL,IAA5B;QAAkC,KAAK,EAAEK,KAAzC;QACU,sBAAsB,EAAED,sBADlC;QAEU,GAAG,EAAEX,IAAI,CAACY,KAAD;MAFnB,GAAeA,KAAf;QAAA;QAAA;QAAA;MAAA,QADH;IADL;MAAA;MAAA;MAAA;IAAA,QADJ,eASI,QAAC,MAAD;MAAQ,IAAI,EAAC,SAAb;MAAuB,KAAK,MAA5B;MAA6B,OAAO,EAAEJ,iBAAtC;MAAA;IAAA;MAAA;MAAA;MAAA;IAAA,QATJ;EAAA;IAAA;IAAA;IAAA;EAAA,QADJ;AAaH,CAzDiC;EAAA,QA4B9BhB,mBA5B8B;AAAA,GAA3B;MAAMS,Q"},"metadata":{},"sourceType":"module"}