/// <reference types="react" />
import { AuthingGuardResponse, AuthingResponse } from '../../_utils/http';
import { CodeStatus } from '../UiQrCode';
import { CodeStatusDescriptions } from '../WorkQrCode';
import { ReducerType, RootState } from './usePreQrCode';
export interface QrCodeResponse {
    /**
     * 根据状态确定不同的流程
     */
    status: number;
    /**
     * 返回的随机值
     */
    random: number;
    /**
     * 返回的用户信息
     */
    userInfo?: any;
    /**
     * 扫码成功后 Tick 换取用户信息
     */
    ticket?: string;
    /**
     * MFA 状态下的返回
     */
    scannedResult?: AuthingResponse;
}
/**
 * 二维码请求相关
 */
interface QrCodeRequest {
    genCodeRequest?: () => Promise<AuthingGuardResponse<{
        random: string;
        url: string;
    }>>;
    /**
     * 未扫码下的请求方法
     */
    readyCheckedRequest?: () => Promise<AuthingGuardResponse<QrCodeResponse>>;
    /**
     * 已经扫码下的请求方法（待确认）
     */
    alreadyCheckedRequest?: () => Promise<AuthingGuardResponse<QrCodeResponse>>;
    /**
     * 使用 ticket 交换用户信息
     */
    exchangeUserInfo?: (ticket: string) => Promise<any>;
}
interface QrCodeOptions {
    state: RootState;
    dispatch: React.Dispatch<{
        type: ReducerType;
        payload: Partial<RootState>;
    }>;
    descriptions: CodeStatusDescriptions;
    sleepTime?: number;
    /**
     * 状态改变时触发事件，仅在 Server 返回的二维码状态改变时进行触发
     */
    onStatusChange?: (status: CodeStatus, data: QrCodeResponse) => void;
}
/**
 * 二维码处理阶段
 * 二维码处理阶段分为两个主要流程
 * 1. 同一状态下的轮询逻辑处理
 * 2. 根据不同返回状态码进行处理
 */
export declare const useQrCode: (options: QrCodeOptions, request: QrCodeRequest) => void;
export {};
