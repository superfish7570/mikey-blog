/**
 * 整体的思路：
 * 在所有登录方式中，当进行登录时保存登录方式（FE侧自定义）
 * 之后在登录成功（onLogin）中，触发store的方法保存用户信息以及对应的登录方式进入localStorage。
 * 当用户再次打开页面时，拿出数据进行对比。（主要对比 LoginWay ），TODO: 这里的代码主要显得乱的原因是因为枚举的不正当使用。（主要要和Server端进行互相映射，后续维护时可优化）
 *
 * 核心思路：登录成功时，保存的FE侧自定义 LoginWay
 * 再次打开页面时，初始化时先根据 FE 自定义的 LoginWay 跳转到不同的 tab 下（way）下使用 account 进行回填。TODO: 这里也可优化，应该在登录成功时候就进行 LoginWay 的格式化，而非转来转去。（但是这样无法直观的体现是哪种方式进行登录）
 */
import { SelectOptions } from '../../../Login/multipleAccounts/panel';
export declare const QR_CODE_WAY: LoginWay[];
/**
 * 登录时所有支持的登录列表(前端定义列表)
 * 这里稍微有点乱 因为Login中的登录方式和这里的不匹配，暂时放在了一起
 */
export declare type LoginWay = 'email' | 'phone' | 'password' | 'phone-code' | 'email-code' | 'social' | 'wechat-miniprogram-qrcode' | 'wechatmp-qrcode' | 'app-qrcode' | 'ad' | 'ldap' | 'ldap-password' | 'ldap-email' | 'ldap-phone';
/**
 * when： 多账号页面跳转进入登录页面
 * 携带的回填数据信息
 */
export interface BackFillMultipleState extends Omit<User, 'id' | 'name' | 'nickname' | 'username' | 'phone' | 'email' | 'photo' | '_updateTime'> {
    /**
     * 回填的账号名称 邮箱/用户名/手机
     */
    account: string;
}
/**
 * Store instance
 */
export declare type StoreInstance = ReturnType<MultipleAccount['getStore']>;
/**
 * 当前 userId 对应的类型
 */
export interface CurrentStore {
    [id: string]: User;
}
export interface User {
    /**
     * userId
     */
    id: string;
    /**
     * Tab 栏状态
     */
    tab: 'input' | 'qrcode';
    /**
     * 登录方式
     */
    way: LoginWay;
    /**
     * 姓名
     */
    name?: string | null;
    /**
     * 昵称
     */
    nickname?: string | null;
    /**
     * 用户名
     */
    username?: string | null;
    /**
     * 手机号
     */
    phone?: string | null;
    /**
     * 邮箱
     */
    email?: string | null;
    /**
     * 头像
     */
    photo?: string | null;
    /**
     * qrCodeId 对应的ID
     */
    qrCodeId?: string;
    /**
     * 国际化短信区号
     */
    phoneCountryCode?: string;
    /**
     * 国际化短信选择框回填
     */
    areaCode?: string;
    /**
     * 登录时间
     */
    _updateTime?: string;
}
declare class MultipleAccount {
    /**
     * 原始的登录账号
     */
    private originAccount;
    private originWay;
    /**
     * 原始的 localStore 值
     */
    private originStore;
    /**
     * 当前 AppId Store
     */
    private currentStore;
    /**
     * 单账号直接回填
     */
    private firstBackFillData?;
    /**
     * server 返回支持的登录方式
     */
    private serverSideLoginMethods;
    /**
     * 是否显示多账号登录页面
     * true 存在
     */
    private memberState;
    /**
     * 二维码登录时的ID
     */
    private qrCodeId?;
    /**
     * 国际化短信前缀 区号
     */
    private phoneCountryCode?;
    /**
     * 国际化短信前缀 选中地区编号
     */
    private areaCode?;
    private tabStatus?;
    /**
     * 当前登录二级状态
     */
    private loginWay?;
    private appId;
    /**
     * 是否开启国际化短信
     */
    private isInternationSms?;
    constructor();
    /**
     * 页面首次加载时初始化 Store
     * 从 LocalStore 中拿值 放到这里来
     */
    private initStore;
    /**
     * 初始化记住账号相关信息
     * @param normalCount
     * @returns
     */
    private initMemberState;
    /**
     * 获取当前ID下有效账号个数
     * @returns qrCount 有效的二维码登录个数 normalCount 有效的账号登录方式
     */
    private memberStateCount;
    /**
     * 初始化第一次的数据 TODO: 逻辑有点脏 待整理
     */
    private initBackfillData;
    /**
     * 根据前端存储的登录方式返回后端映射方式
     * @param front
     */
    private getServerLoginMethodByFront;
    /**
     * 当前 Store  DONE
     */
    private getCurrentStore;
    /**
     * 国际化短信过滤
     * true 表示通过 需要保留
     * false 表示不通过 需要过滤
     */
    private validateInternationSms;
    /**
     * 校验有效的登录方式账号
     * @param user
     * @param serverSideLoginMethods
     * @returns
     */
    private validateMethod;
    /**
     *
     * @param tab 一级Tab状态
     * @param way 二级Tab状态
     * @param id 二维码登录时 记录对应的二维码 ID
     */
    private setLoginWay;
    /**
     * 设置/更新 store 内的用户信息
     */
    private setUserInfo;
    /**
     * 持久化保存
     */
    private saveStore;
    /**
     * 根据登录的 account 判断本次登录的方式
     * @param account 登录输入的账号
     * @param param1 登录成功返回的相关信息 用户名/手机号/邮箱
     * @returns
     */
    private setLoginWayByHttpData;
    /**
     * 根据登录的 account 判断本次LDAP登录方式
     * @param account 登录输入的账号
     * @param param1 登录成功返回的相关信息 用户名/手机号/邮箱
     * @returns
     */
    private setLoginWayByLDAPData;
    /**
     * 根据用户 ID 删除 localStorage 中当前用户 ID
     */
    private delUserById;
    /**
     * 获得多账号登录页面的所有用户列表
     * @param excludeWays
     */
    private getMemoUser;
    /**
     * 根据 id 获得当前已登录的用户信息
     * @param userId
     * @returns User / undefined
     */
    private getMemoSingleUser;
    /**
     * 该方法仅仅需要回填账号的登录方式，其他都不计入
     * 当用户名/手机号/邮箱/AD/LDAP 相同时，根据登录顺序匹配不同的账号
     * 根据记住的用户登录方式获取对应的登录账户名
     * @param way
     * @param user
     * @returns
     */
    private getAccountByWay;
    private _mappingUser;
    /**
     * 外部暴露方法
     */
    getStore: () => {
        initStore: (appId: string, options: {
            serverSideLoginMethods: LoginWay[];
            isInternationSms: boolean;
        }) => void;
        setLoginWay: (tab: 'input' | 'qrcode', way: LoginWay, id?: string | undefined, internation?: {
            phoneCountryCode: string;
            areaCode: string;
        } | undefined) => void;
        setUserInfo: (user: Pick<User & {
            id: string;
        }, "email" | "username" | "phone" | "photo" | "id" | "name" | "nickname" | "_updateTime" | "qrCodeId" | "areaCode">) => void;
        setLoginWayByHttpData: (account: string, data: {
            username?: string | undefined;
            phone?: string | undefined;
            email?: string | undefined;
        }) => void;
        setLoginWayByLDAPData: (account: string, data: {
            name?: string | undefined;
            phone?: string | undefined;
            email?: string | undefined;
        }) => void;
        getMemoUser: (excludeWays?: LoginWay[]) => SelectOptions[];
        getMemoSingleUser: (id: string) => {
            way: LoginWay;
            account: string;
        } | undefined;
        delUserById: (id: string) => string;
        getMemberState: () => boolean;
        getFirstBackFillData: () => BackFillMultipleState | undefined;
        getOriginAccount: () => string;
        getOriginWay: () => string;
    };
}
/**
 * MultipleAccounts 相关 Hook
 * Finally Config 类型过滤
 */
declare const useMultipleAccounts: ({ appId, finallyConfig, }: {
    appId?: string | undefined;
    finallyConfig?: any;
}) => {
    instance: {
        initStore: (appId: string, options: {
            serverSideLoginMethods: LoginWay[];
            isInternationSms: boolean;
        }) => void;
        setLoginWay: (tab: 'input' | 'qrcode', way: LoginWay, id?: string | undefined, internation?: {
            phoneCountryCode: string;
            areaCode: string;
        } | undefined) => void;
        setUserInfo: (user: Pick<User & {
            id: string;
        }, "email" | "username" | "phone" | "photo" | "id" | "name" | "nickname" | "_updateTime" | "qrCodeId" | "areaCode">) => void;
        setLoginWayByHttpData: (account: string, data: {
            username?: string | undefined;
            phone?: string | undefined;
            email?: string | undefined;
        }) => void;
        setLoginWayByLDAPData: (account: string, data: {
            name?: string | undefined;
            phone?: string | undefined;
            email?: string | undefined;
        }) => void;
        getMemoUser: (excludeWays?: LoginWay[]) => SelectOptions[];
        getMemoSingleUser: (id: string) => {
            way: LoginWay;
            account: string;
        } | undefined;
        delUserById: (id: string) => string;
        getMemberState: () => boolean;
        getFirstBackFillData: () => BackFillMultipleState | undefined;
        getOriginAccount: () => string;
        getOriginWay: () => string;
    } | undefined;
    isMultipleAccount: boolean;
    referMultipleState: (type: 'login' | 'multiple', data?: BackFillMultipleState | undefined) => void;
    multipleAccountData: BackFillMultipleState | undefined;
    clearBackFillData: () => void;
};
export default useMultipleAccounts;
