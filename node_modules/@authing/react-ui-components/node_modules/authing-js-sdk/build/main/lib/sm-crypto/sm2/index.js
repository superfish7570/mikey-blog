"use strict";
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    Object.defineProperty(o, k2, { enumerable: true, get: function() { return m[k]; } });
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
var __spreadArray = (this && this.__spreadArray) || function (to, from) {
    for (var i = 0, il = from.length, j = to.length; i < il; i++, j++)
        to[j] = from[i];
    return to;
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.getPoint = exports.doVerifySignature = exports.doSignature = exports.doDecrypt = exports.doEncrypt = exports.verifyPublicKey = exports.generateKeyPairHex = void 0;
var jsbn_1 = require("jsbn");
var asn1_1 = require("./asn1");
var _ = __importStar(require("./utils"));
var sm3_1 = __importDefault(require("./sm3"));
var _a = _.generateEcparam(), G = _a.G, curve = _a.curve, n = _a.n;
var C1C2C3 = 0;
/**
 * 加密
 */
function doEncrypt(msg, publicKey, cipherMode) {
    if (cipherMode === void 0) { cipherMode = 1; }
    msg =
        typeof msg === 'string'
            ? _.hexToArray(_.utf8ToHex(msg))
            : Array.prototype.slice.call(msg);
    publicKey = _.getGlobalCurve().decodePointHex(publicKey); // 先将公钥转成点
    var keypair = _.generateKeyPairHex();
    var k = new jsbn_1.BigInteger(keypair.privateKey, 16); // 随机数 k
    // c1 = k * G
    var c1 = keypair.publicKey;
    if (c1.length > 128)
        c1 = c1.substr(c1.length - 128);
    // (x2, y2) = k * publicKey
    var p = publicKey.multiply(k);
    var x2 = _.hexToArray(_.leftPad(p
        .getX()
        .toBigInteger()
        .toRadix(16), 64));
    var y2 = _.hexToArray(_.leftPad(p
        .getY()
        .toBigInteger()
        .toRadix(16), 64));
    // c3 = hash(x2 || msg || y2)
    var c3 = _.arrayToHex(sm3_1.default([].concat(x2, msg, y2)));
    var ct = 1;
    var offset = 0;
    var t = []; // 256 位
    var z = [].concat(x2, y2);
    var nextT = function () {
        // (1) Hai = hash(z || ct)
        // (2) ct++
        t = sm3_1.default(__spreadArray(__spreadArray([], z), [
            (ct >> 24) & 0x00ff,
            (ct >> 16) & 0x00ff,
            (ct >> 8) & 0x00ff,
            ct & 0x00ff
        ]));
        ct++;
        offset = 0;
    };
    nextT(); // 先生成 Ha1
    for (var i = 0, len = msg.length; i < len; i++) {
        // t = Ha1 || Ha2 || Ha3 || Ha4
        if (offset === t.length)
            nextT();
        // c2 = msg ^ t
        msg[i] ^= t[offset++] & 0xff;
    }
    var c2 = _.arrayToHex(msg);
    return cipherMode === C1C2C3 ? c1 + c2 + c3 : c1 + c3 + c2;
}
exports.doEncrypt = doEncrypt;
/**
 * 解密
 */
function doDecrypt(encryptData, privateKey, cipherMode, _a) {
    if (cipherMode === void 0) { cipherMode = 1; }
    var _b = _a === void 0 ? {} : _a, _c = _b.output, output = _c === void 0 ? 'string' : _c;
    privateKey = new jsbn_1.BigInteger(privateKey, 16);
    var c3 = encryptData.substr(128, 64);
    var c2 = encryptData.substr(128 + 64);
    if (cipherMode === C1C2C3) {
        c3 = encryptData.substr(encryptData.length - 64);
        c2 = encryptData.substr(128, encryptData.length - 128 - 64);
    }
    var msg = _.hexToArray(c2);
    var c1 = _.getGlobalCurve().decodePointHex('04' + encryptData.substr(0, 128));
    var p = c1.multiply(privateKey);
    var x2 = _.hexToArray(_.leftPad(p
        .getX()
        .toBigInteger()
        .toRadix(16), 64));
    var y2 = _.hexToArray(_.leftPad(p
        .getY()
        .toBigInteger()
        .toRadix(16), 64));
    var ct = 1;
    var offset = 0;
    var t = []; // 256 位
    var z = [].concat(x2, y2);
    var nextT = function () {
        // (1) Hai = hash(z || ct)
        // (2) ct++
        t = sm3_1.default(__spreadArray(__spreadArray([], z), [
            (ct >> 24) & 0x00ff,
            (ct >> 16) & 0x00ff,
            (ct >> 8) & 0x00ff,
            ct & 0x00ff
        ]));
        ct++;
        offset = 0;
    };
    nextT(); // 先生成 Ha1
    for (var i = 0, len = msg.length; i < len; i++) {
        // t = Ha1 || Ha2 || Ha3 || Ha4
        if (offset === t.length)
            nextT();
        // c2 = msg ^ t
        msg[i] ^= t[offset++] & 0xff;
    }
    // c3 = hash(x2 || msg || y2)
    var checkC3 = _.arrayToHex(sm3_1.default([].concat(x2, msg, y2)));
    if (checkC3 === c3) {
        return output === 'array' ? msg : _.arrayToUtf8(msg);
    }
    else {
        return output === 'array' ? [] : '';
    }
}
exports.doDecrypt = doDecrypt;
/**
 * 签名
 */
function doSignature(msg, privateKey, _a) {
    var _b = _a === void 0 ? {} : _a, pointPool = _b.pointPool, der = _b.der, hash = _b.hash, publicKey = _b.publicKey, userId = _b.userId;
    var hashHex = typeof msg === 'string' ? _.utf8ToHex(msg) : _.arrayToHex(msg);
    if (hash) {
        // sm3杂凑
        publicKey = publicKey || getPublicKeyFromPrivateKey(privateKey);
        hashHex = getHash(hashHex, publicKey, userId);
    }
    var dA = new jsbn_1.BigInteger(privateKey, 16);
    var e = new jsbn_1.BigInteger(hashHex, 16);
    // k
    var k = null;
    var r = null;
    var s = null;
    do {
        do {
            var point = void 0;
            if (pointPool && pointPool.length) {
                point = pointPool.pop();
            }
            else {
                point = getPoint();
            }
            k = point.k;
            // r = (e + x1) mod n
            r = e.add(point.x1).mod(n);
        } while (r.equals(jsbn_1.BigInteger.ZERO) || r.add(k).equals(n));
        // s = ((1 + dA)^-1 * (k - r * dA)) mod n
        s = dA
            .add(jsbn_1.BigInteger.ONE)
            .modInverse(n)
            .multiply(k.subtract(r.multiply(dA)))
            .mod(n);
    } while (s.equals(jsbn_1.BigInteger.ZERO));
    if (der)
        return asn1_1.encodeDer(r, s); // asn.1 der 编码
    return _.leftPad(r.toString(16), 64) + _.leftPad(s.toString(16), 64);
}
exports.doSignature = doSignature;
/**
 * 验签
 */
function doVerifySignature(msg, signHex, publicKey, _a) {
    var _b = _a === void 0 ? {} : _a, der = _b.der, hash = _b.hash, userId = _b.userId;
    var hashHex = typeof msg === 'string' ? _.utf8ToHex(msg) : _.arrayToHex(msg);
    if (hash) {
        // sm3杂凑
        hashHex = getHash(hashHex, publicKey, userId);
    }
    var r;
    var s;
    if (der) {
        var decodeDerObj = asn1_1.decodeDer(signHex); // asn.1 der 解码
        r = decodeDerObj.r;
        s = decodeDerObj.s;
    }
    else {
        r = new jsbn_1.BigInteger(signHex.substring(0, 64), 16);
        s = new jsbn_1.BigInteger(signHex.substring(64), 16);
    }
    var PA = curve.decodePointHex(publicKey);
    var e = new jsbn_1.BigInteger(hashHex, 16);
    // t = (r + s) mod n
    var t = r.add(s).mod(n);
    if (t.equals(jsbn_1.BigInteger.ZERO))
        return false;
    // x1y1 = s * G + t * PA
    var x1y1 = G.multiply(s).add(PA.multiply(t));
    // R = (e + x1) mod n
    var R = e.add(x1y1.getX().toBigInteger()).mod(n);
    return r.equals(R);
}
exports.doVerifySignature = doVerifySignature;
/**
 * sm3杂凑算法
 */
function getHash(hashHex, publicKey, userId) {
    if (userId === void 0) { userId = '1234567812345678'; }
    // z = hash(entl || userId || a || b || gx || gy || px || py)
    userId = _.utf8ToHex(userId);
    var a = _.leftPad(G.curve.a.toBigInteger().toRadix(16), 64);
    var b = _.leftPad(G.curve.b.toBigInteger().toRadix(16), 64);
    var gx = _.leftPad(G.getX()
        .toBigInteger()
        .toRadix(16), 64);
    var gy = _.leftPad(G.getY()
        .toBigInteger()
        .toRadix(16), 64);
    if (publicKey.length > 128)
        publicKey = publicKey.substr(2, 128); // 干掉 '04'
    var px = publicKey.substr(0, 64);
    var py = publicKey.substr(64, 64);
    var data = _.hexToArray(userId + a + b + gx + gy + px + py);
    var entl = userId.length * 4;
    data.unshift(entl & 0x00ff);
    data.unshift((entl >> 8) & 0x00ff);
    var z = sm3_1.default(data);
    // e = hash(z || msg)
    return _.arrayToHex(sm3_1.default(z.concat(_.hexToArray(hashHex))));
}
/**
 * 计算公钥
 */
function getPublicKeyFromPrivateKey(privateKey) {
    var PA = G.multiply(new jsbn_1.BigInteger(privateKey, 16));
    var x = _.leftPad(PA.getX()
        .toBigInteger()
        .toString(16), 64);
    var y = _.leftPad(PA.getY()
        .toBigInteger()
        .toString(16), 64);
    return '04' + x + y;
}
/**
 * 获取椭圆曲线点
 */
function getPoint() {
    var keypair = _.generateKeyPairHex();
    var PA = curve.decodePointHex(keypair.publicKey);
    keypair.k = new jsbn_1.BigInteger(keypair.privateKey, 16);
    keypair.x1 = PA.getX().toBigInteger();
    return keypair;
}
exports.getPoint = getPoint;
exports.generateKeyPairHex = _.generateKeyPairHex;
exports.verifyPublicKey = _.verifyPublicKey;
//# sourceMappingURL=index.js.map